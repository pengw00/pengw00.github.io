<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pengw00&#39;s Tech Road</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://pengw00.github.io/"/>
  <updated>2019-04-04T03:33:10.204Z</updated>
  <id>http://pengw00.github.io/</id>
  
  <author>
    <name>pengw00</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>路径选择的dp问题之三角形最小路径和</title>
    <link href="http://pengw00.github.io/2019/04/03/%E8%B7%AF%E5%BE%84%E9%80%89%E6%8B%A9%E7%9A%84dp%E9%97%AE%E9%A2%98%E4%B9%8B%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>http://pengw00.github.io/2019/04/03/路径选择的dp问题之三角形最小路径和/</id>
    <published>2019-04-04T03:16:36.000Z</published>
    <updated>2019-04-04T03:33:10.204Z</updated>
    
    <content type="html"><![CDATA[<ol start="120"><li>三角形最小路径和</li></ol><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p><p>例如，给定三角形：</p><p>[<br>     [2],<br>    [3,4],<br>   [6,5,7],<br>  [4,1,8,3]<br>]<br>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</p><p>如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分.暂时没想到。。。（可能是用in-place方法）可行。</p><p>这道题类似于hmm的路径中选择概率最大的乘织。<br>采用topdown的dp 方法，最顶端的点决定于左右下方两侧的点的minsum，不能采用bottomup的方法。因为可能出现local最优值。<br>思路是经过当前节点的最小路径为左右节点的路径的最小值加自身，从上往下递归（top down），如果从下往上选，这个思路将是错的，因为你的局部最小并不可以确定最优会经过这里，所以从源头定点开始。<br>采用递归的方法构造，minsum(trangle, 0, 0).<br>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution1 &#123;</span><br><span class="line"> </span><br><span class="line">private:</span><br><span class="line"> </span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; memo;</span><br><span class="line">//cache</span><br><span class="line">int m;// 行数</span><br><span class="line"> </span><br><span class="line">// i,j代表当前节点的索引</span><br><span class="line">int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; triangle, int i, int j) &#123;</span><br><span class="line"> </span><br><span class="line">if (i == m - 1)</span><br><span class="line">return triangle[i][j];</span><br><span class="line"> </span><br><span class="line">// 相同结构子问题的递归</span><br><span class="line">if (memo[i][j] == -1) &#123;</span><br><span class="line">memo[i][j] = min(minPathSum(triangle, i + 1, j), minPathSum(triangle, i + 1, j + 1)) + triangle[i][j];</span><br><span class="line">cout &lt;&lt;&quot;memo[&quot;&lt;&lt;i&lt;&lt;&quot;][&quot;&lt;&lt;j&lt;&lt;&quot;] : &quot;&lt;&lt; memo[i][j] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return memo[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123;</span><br><span class="line"> </span><br><span class="line">if (triangle.size() == 0)</span><br><span class="line">return 0;</span><br><span class="line"> </span><br><span class="line">// triangle中应该都是正数吧</span><br><span class="line">int res;</span><br><span class="line">m = triangle.size();</span><br><span class="line">//构造cache容器</span><br><span class="line">for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">vector&lt;int&gt; tmp(triangle[i].size(), -1);</span><br><span class="line">memo.push_back(tmp);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">res = minPathSum(triangle, 0, 0);</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>//犹记得当日的nlp课程的hmm状态转移方法，yangsky算法，一个句子在一个概率字典里找出最有可能的点。当时查找路径。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol start=&quot;120&quot;&gt;
&lt;li&gt;三角形最小路径和&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。&lt;/p&gt;
&lt;p&gt;例如，给定三角形：&lt;/p&gt;
&lt;p&gt;[&lt;br&gt;     [2],&lt;br&gt;    [3,4],&lt;br
      
    
    </summary>
    
    
      <category term="algorithm" scheme="http://pengw00.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>topK and quickSort and QuickSelect</title>
    <link href="http://pengw00.github.io/2019/04/03/topK-and-quickSort-and-QuickSelect/"/>
    <id>http://pengw00.github.io/2019/04/03/topK-and-quickSort-and-QuickSelect/</id>
    <published>2019-04-03T17:36:40.000Z</published>
    <updated>2019-04-03T17:36:40.828Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Quick Sort&#39; </title>
    <link href="http://pengw00.github.io/2019/04/03/Quick-Sort/"/>
    <id>http://pengw00.github.io/2019/04/03/Quick-Sort/</id>
    <published>2019-04-03T15:43:47.000Z</published>
    <updated>2019-04-03T15:50:48.701Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void quickSort(int[] arr, int low, int high)&#123;</span><br><span class="line">if(low&gt;high) return;</span><br><span class="line">int i = low, int j = high, base = arr[low];</span><br><span class="line">while(i &lt; j)&#123;</span><br><span class="line">while(arr[i]&lt;base &amp;&amp; i&lt;j)&#123;i++;&#125;</span><br><span class="line">while(arr[j]&gt;base &amp;&amp; i &lt; j)&#123; j--;&#125;</span><br><span class="line">//after that the order is messy</span><br><span class="line">swap(arr, low, j);</span><br><span class="line">&#125;</span><br><span class="line">swap(arr, base, j);</span><br><span class="line">quickSort(arr, low, j-1);</span><br><span class="line">quickSort(arr, j+1, high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void swap(int[] arr, int i, int j)&#123;</span><br><span class="line">int temp = arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = tamp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="algorithm" scheme="http://pengw00.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>axios instance</title>
    <link href="http://pengw00.github.io/2019/04/03/axios-instance/"/>
    <id>http://pengw00.github.io/2019/04/03/axios-instance/</id>
    <published>2019-04-03T14:31:17.000Z</published>
    <updated>2019-04-03T14:32:46.136Z</updated>
    
    <content type="html"><![CDATA[<p>Question??<br>axios.create({ baseURL: ajaxUrl,timeout: 30000,withCredentials: true}) 创建实例作用是啥 没有不行吗### 问题描述<br>引入axios,然后在页面中进行请求axios.get(‘url’).then(res=&gt;{}),这里的创建实例充当什么角色</p><p>Answer:<br>默认会导出实例axios，通常你只需使用这个axios就可以了。</p><p>但是有时候你需要创建多个实例，比如你需要访问多个服务地址，而这些服务请求和响应的结构都完全不同，那么你可以通过axios.create创建不同的实例来处理。</p><p>比如axios1是用http状态码确定响应是否正常，而axios2是服务器自己定义的状态码，又或者他们请求头不同，支持的content-type不同，那么我可以单独为axios1和axios2写拦截器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Question??&lt;br&gt;axios.create({ baseURL: ajaxUrl,timeout: 30000,withCredentials: true}) 创建实例作用是啥 没有不行吗### 问题描述&lt;br&gt;引入axios,然后在页面中进行请求axios.ge
      
    
    </summary>
    
    
      <category term="React" scheme="http://pengw00.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>dfs和回溯模版</title>
    <link href="http://pengw00.github.io/2019/04/03/dfs%E5%92%8C%E5%9B%9E%E6%BA%AF%E6%A8%A1%E7%89%88/"/>
    <id>http://pengw00.github.io/2019/04/03/dfs和回溯模版/</id>
    <published>2019-04-03T05:12:04.000Z</published>
    <updated>2019-04-03T05:15:21.030Z</updated>
    
    <content type="html"><![CDATA[<p>dfs template<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void f()  </span><br><span class="line">&#123;  </span><br><span class="line">     if(符合边界条件)  </span><br><span class="line">     &#123;  </span><br><span class="line"></span><br><span class="line">        ///////  </span><br><span class="line">        return;  </span><br><span class="line">     &#125;  </span><br><span class="line"></span><br><span class="line">     //某种形式的调用  </span><br><span class="line">     f();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>回溯模版： 限制条件 if，选择 （for。。。）结束条件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void DFS(int 当前状态)  </span><br><span class="line">&#123;  </span><br><span class="line">      if(当前状态为边界状态)  </span><br><span class="line">      &#123;  </span><br><span class="line">        记录或输出  </span><br><span class="line">        return;  </span><br><span class="line">      &#125;  </span><br><span class="line">      for(i=0;i&lt;n;i++)       //横向遍历解答树所有子节点  </span><br><span class="line">      &#123;  </span><br><span class="line">           //扩展出一个子状态。  </span><br><span class="line">           修改了全局变量  </span><br><span class="line">           if(子状态满足约束条件)  </span><br><span class="line">            &#123;  </span><br><span class="line">              dfs(子状态)  </span><br><span class="line">           &#125;  </span><br><span class="line">            恢复全局变量//回溯部分  </span><br><span class="line">      &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>BFS和DFS相似。BFS显式用队列，DFS隐式用栈，即递归。<br>当然，对于DFS，用递归可能会造成栈溢出，所以也可以更改为显示栈。</p><p>经典例题： 走迷宫<br>*表示可走 </p><p>#表示障碍<br>T表示出口<br>入口是(1,1)，数据保证左上角是入口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">char maze[100][100];</span><br><span class="line">bool flag[100][100];</span><br><span class="line">int dx[]=&#123;0,0,1,-1&#125;;</span><br><span class="line">int dy[]=&#123;1,-1,0,0&#125;;</span><br><span class="line">int m,n;</span><br><span class="line"></span><br><span class="line">bool dfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    flag[x][y]=1;              //走过的路标记为1</span><br><span class="line">    if(maze[x][y]==&apos;T&apos;)return true;</span><br><span class="line">    for(int i=0;i&lt;4;i++)       //四个方向</span><br><span class="line">    &#123;</span><br><span class="line">        int nx=x+dx[i];</span><br><span class="line">        int ny=y+dy[i];</span><br><span class="line">        if(flag[nx][ny]==0||maze[nx][ny]==&apos;*&apos;||maze[nx][ny]==&apos;T&apos;&amp;&amp;nx&gt;0&amp;&amp;ny&gt;0&amp;&amp;nx&lt;m+1&amp;&amp;ny&lt;n+1)</span><br><span class="line">        &#123;</span><br><span class="line">            return dfs(nx,ny);   </span><br><span class="line">            flag[nx][ny]=0;    //回溯，将标记重新标记为0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;             //找不到返回false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    while(cin&gt;&gt;m&gt;&gt;n)&#123;</span><br><span class="line">    memset(maze,0,sizeof(maze));</span><br><span class="line">    memset(flag,0,sizeof(flag));</span><br><span class="line">    for(int i=1;i&lt;=m;i++)</span><br><span class="line">        for(int j=1;j&lt;=n;j++)</span><br><span class="line">            cin&gt;&gt;maze[i][j];</span><br><span class="line">    if(dfs(1,1))cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">    else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;dfs template&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/s
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://pengw00.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>回溯，递归，dp三法leetcode 题目“ </title>
    <link href="http://pengw00.github.io/2019/04/03/%E5%9B%9E%E6%BA%AF%EF%BC%8C%E9%80%92%E5%BD%92%EF%BC%8Cdp%E4%B8%89%E6%B3%95leetcode-%E9%A2%98%E7%9B%AE%E2%80%9C/"/>
    <id>http://pengw00.github.io/2019/04/03/回溯，递归，dp三法leetcode-题目“/</id>
    <published>2019-04-03T04:30:53.000Z</published>
    <updated>2019-04-03T04:59:05.205Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode 10  regular expression matching 可以减去一字符<br>leetcode wildcard matching 可以匹配一个字符<br>leetcode edit distance<br>回溯三要素：选择，限制条件，结束条件<br>回溯是一种算法思想，它是用递归实现的。回溯的过程类似于穷举法，但回溯有“剪枝”功能，即自我判断过程。例如有求和问题，给定有 7 个元素的组合 [1, 2, 3, 4, 5, 6, 7]，求加和为 7 的子集。累加计算中，选择 1+2+3+4 时，判断得到结果为 10 大于 7，那么后面的 5, 6, 7 就没有必要计算了。这种方法属于搜索过程中的优化，即“剪枝”功能。</p><p>回溯法解决leetcode10注意递归和回溯的区别<br>回溯具有剪枝的功能。当出现结束条件，自动回溯，不必再往不必要的地方搜索。</p><p>我们在路上走着，前面是一个多岔路口，因为我们并不知道应该走哪条路，所以我们需要尝试。尝试的过程就是一个函数。<br>我们选择了一个方向，后来发现又有一个多岔路口，这时候又需要进行一次选择。所以我们需要在上一次尝试结果的基础上，再做一次尝试，即在函数内部再调用一次函数，这就是递归的过程。<br>这样重复了若干次之后，发现这次选择的这条路走不通，这时候我们知道我们上一个路口选错了，所以我们要回到上一个路口重新选择其他路，这就是回溯的思想。</p><p>递归和回溯相关题目：<br>leetcode17 letter Combinations of a Phone Number<br>leetcode22 Generate Parentheses(最为经典)<br>leetcode46 permutations<br>在 Backtracking 标签中，有 30+ 道与递归、回溯相关的例题</p><p>回溯搜索是深度优先搜索（DFS）的一种。对于某一个搜索树来说（搜索树是起记录路径和状态判断的作用），回溯和DFS，其主要的区别是，回溯法在求解过程中不保留完整的树结构，而深度优先搜索则记下完整的搜索树。</p><p><a href="http://www.cnblogs.com/shizhh/p/5302852.html" target="_blank" rel="noopener">http://www.cnblogs.com/shizhh/p/5302852.html</a> 动态规划系列问题汇总</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;leetcode 10  regular expression matching 可以减去一字符&lt;br&gt;leetcode wildcard matching 可以匹配一个字符&lt;br&gt;leetcode edit distance&lt;br&gt;回溯三要素：选择，限制条件，结束条件&lt;b
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://pengw00.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>springSecurity Bcrypt hash password</title>
    <link href="http://pengw00.github.io/2019/04/02/springSecurity-Bcrypt-hash-password/"/>
    <id>http://pengw00.github.io/2019/04/02/springSecurity-Bcrypt-hash-password/</id>
    <published>2019-04-02T04:12:46.000Z</published>
    <updated>2019-04-02T04:25:57.506Z</updated>
    
    <content type="html"><![CDATA[<p>SpringSecurity之加密篇—BCryptpassword类</p><ol><li>要点概括<br>BCryptpassword类是SpringSecurity的加密工具，封装了对密码混淆加密的方法，主要是采用盐（salt）对原始密码进行混淆。<br>本篇介绍的是利用BCryptpassword随机生成盐（salt），使用该盐值对原始密码进行混淆加密。<br>这种加密方式有两个特点：（1）将随机生成的盐（salt）存到混淆后的代码中；（2）对于相同的明文每一次加密，加密之后的密文都是不一样的；因为盐值（salt）不同。这样的好处就是更增加了密码的安全性。</li></ol><p>SpringSecurity中的BCryptPassword采用Hash处理，其过程是不可逆的。</p><p>BCryptPassword的加密过程：<br>（1）加密(encode)：用户注册时，使用SHA256+盐（salt）把用户输入的密码进行hash混淆处理，得到密码的hash值，然后将其存入数据库中。<br>（2）密码校验(matches)：用户登录时，密码匹配阶段并没有进行密码解密（因为密码经过Hash处理，是不可逆的），而是使用相同的算法结合盐值salt把用户输入的密码进行hash处理，得到密码的hash值，然后将其与从数据库中查询到的密码hash值进行比较。如果两者相同，说明用户输入的密码正确，这里的盐值（salt）是从数据库中查询到的密码hash值中解析出来的。</p><ol start="2"><li>核心代码分析<br>//1. BCryptPasswordEncoder类，生成盐salt并混淆rawpassword的代码；<br>//涉及到两个问题，生成salt盐gensalt()，混淆密码hashpw()<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public String encode(CharSequence rawPassword) &#123;</span><br><span class="line">    String salt;</span><br><span class="line">    if (this.strength &gt; 0) &#123;</span><br><span class="line">        if (this.random != null) &#123;</span><br><span class="line">            salt = BCrypt.gensalt(this.strength, this.random);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            salt = BCrypt.gensalt(this.strength);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        salt = BCrypt.gensalt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return BCrypt.hashpw(rawPassword.toString(), salt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>2.1 生成盐（salt）：<br>:包名：org.springframework.security.crypto.bcrypt；类名：BCrypt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//生成salt盐gensalt() </span><br><span class="line">   public static String gensalt(int log_rounds, SecureRandom random) &#123;</span><br><span class="line">       if (log_rounds &gt;= 4 &amp;&amp; log_rounds &lt;= 31) &#123;</span><br><span class="line">           StringBuilder rs = new StringBuilder();</span><br><span class="line">           byte[] rnd = new byte[16];</span><br><span class="line">           random.nextBytes(rnd);</span><br><span class="line">           rs.append(&quot;$2a$&quot;);</span><br><span class="line">           if (log_rounds &lt; 10) &#123;</span><br><span class="line">               rs.append(&quot;0&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           rs.append(log_rounds);</span><br><span class="line">           rs.append(&quot;$&quot;);</span><br><span class="line">           encode_base64(rnd, rnd.length, rs);</span><br><span class="line">           return rs.toString();</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           throw new IllegalArgumentException(&quot;Bad number of rounds&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>2.2 混淆方法：<br>包名：org.springframework.security.crypto.bcrypt；类名：BCrypt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">//混淆密码hashpw()</span><br><span class="line">public static String hashpw(String password, String salt) throws IllegalArgumentException &#123;</span><br><span class="line">        char minor = 0;</span><br><span class="line">        int off = false;</span><br><span class="line">        StringBuilder rs = new StringBuilder();</span><br><span class="line">        if (salt == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;salt cannot be null&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int saltLength = salt.length();</span><br><span class="line">            if (saltLength &lt; 28) &#123;</span><br><span class="line">                throw new IllegalArgumentException(&quot;Invalid salt&quot;);</span><br><span class="line">            &#125; else if (salt.charAt(0) == &apos;$&apos; &amp;&amp; salt.charAt(1) == &apos;2&apos;) &#123;</span><br><span class="line">                byte off;</span><br><span class="line">                if (salt.charAt(2) == &apos;$&apos;) &#123;</span><br><span class="line">                    off = 3;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    minor = salt.charAt(2);</span><br><span class="line">                    if (minor != &apos;a&apos; || salt.charAt(3) != &apos;$&apos;) &#123;</span><br><span class="line">                        throw new IllegalArgumentException(&quot;Invalid salt revision&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    off = 4;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (saltLength - off &lt; 25) &#123;</span><br><span class="line">                    throw new IllegalArgumentException(&quot;Invalid salt&quot;);</span><br><span class="line">                &#125; else if (salt.charAt(off + 2) &gt; &apos;$&apos;) &#123;</span><br><span class="line">                    throw new IllegalArgumentException(&quot;Missing salt rounds&quot;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    int rounds = Integer.parseInt(salt.substring(off, off + 2));</span><br><span class="line">                    String real_salt = salt.substring(off + 3, off + 25);</span><br><span class="line"></span><br><span class="line">                    byte[] passwordb;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        passwordb = (password + (minor &gt;= &apos;a&apos; ? &quot;\u0000&quot; : &quot;&quot;)).getBytes(&quot;UTF-8&quot;);</span><br><span class="line">                    &#125; catch (UnsupportedEncodingException var13) &#123;</span><br><span class="line">                        throw new AssertionError(&quot;UTF-8 is not supported&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    byte[] saltb = decode_base64(real_salt, 16);</span><br><span class="line">                    BCrypt B = new BCrypt();</span><br><span class="line">                    byte[] hashed = B.crypt_raw(passwordb, saltb, rounds);</span><br><span class="line">                    rs.append(&quot;$2&quot;);</span><br><span class="line">                    if (minor &gt;= &apos;a&apos;) &#123;</span><br><span class="line">                        rs.append(minor);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    rs.append(&quot;$&quot;);</span><br><span class="line">                    if (rounds &lt; 10) &#123;</span><br><span class="line">                        rs.append(&quot;0&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    rs.append(rounds);</span><br><span class="line">                    rs.append(&quot;$&quot;);</span><br><span class="line">                    encode_base64(saltb, saltb.length, rs);</span><br><span class="line">                    encode_base64(hashed, bf_crypt_ciphertext.length * 4 - 1, rs);</span><br><span class="line">                    return rs.toString();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new IllegalArgumentException(&quot;Invalid salt version&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>2.3 密码的校验<br>提供的密码与加密之后的密码的校验，使用是BCryptpassword的matches()接口；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public boolean matches(CharSequence rawPassword, String encodedPassword) &#123;</span><br><span class="line">    if (encodedPassword != null &amp;&amp; encodedPassword.length() != 0) &#123;</span><br><span class="line">        if (!this.BCRYPT_PATTERN.matcher(encodedPassword).matches()) &#123;</span><br><span class="line">            this.logger.warn(&quot;Encoded password does not look like BCrypt&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return BCrypt.checkpw(rawPassword.toString(), encodedPassword);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        this.logger.warn(&quot;Empty encoded password&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><pre><code>/** * 密码比较入口，同样是调用了hashpw()方法: 使用的是hashpw()方法，有两个参数：原始明文与数据库中获取的密文。 * hashpw()方法是从密文中解析出藏在其中的盐salt值，用此值混淆明文，与密文做比较。 */</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   public static boolean checkpw(String plaintext, String hashed) &#123;</span><br><span class="line">       return equalsNoEarlyReturn(hashed, hashpw(plaintext, hashed)); </span><br><span class="line">   &#125;</span><br><span class="line">//这个方法就是比较是否相同而已，无他。</span><br><span class="line">   static boolean equalsNoEarlyReturn(String a, String b) &#123;</span><br><span class="line">       char[] caa = a.toCharArray();</span><br><span class="line">       char[] cab = b.toCharArray();</span><br><span class="line">       if (caa.length != cab.length) &#123;</span><br><span class="line">           return false;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           byte ret = 0;</span><br><span class="line"></span><br><span class="line">           for(int i = 0; i &lt; caa.length; ++i) &#123;</span><br><span class="line">               ret = (byte)(ret | caa[i] ^ cab[i]);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           return ret == 0;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>总结<br>以上是SpringSecurity的BCryptPassword加密方式，上面是介绍其SHA256+随机salt生成密文的基本点。应该还有其他的一些用法，容当后研究。</p></li><li><p>其它<br>Springboot框架整合SpringSecurity组件，使用需要使用该加密方式，有一点需要注意，就是在springSecurity的配置文件中注入PasswordEncode的bean</p><p> //SpringSecurityConfigutarion配置类中加入<br> @Bean<br> public PasswordEncoder passwordEncoder() {</p><pre><code>return new BCryptPasswordEncoder();</code></pre><p> }<br>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       String password = &quot;leo_epam&quot;;</span><br><span class="line">        System.out.println(password + &quot;: encrypt&quot;);</span><br><span class="line">        int i = 0;</span><br><span class="line">        while(i &lt; 10)&#123;</span><br><span class="line">            BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();</span><br><span class="line">            String hashedPassword = passwordEncoder.encode(password);</span><br><span class="line">            System.out.println(&quot;encryptPassword:&quot; + hashedPassword);</span><br><span class="line">            System.out.println(&quot;match result:&quot; + passwordEncoder.matches(password,hashedPassword));</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p>代码输出：</p><p>leo_epam: encrypt<br>encryptPassword:$2a$10$/WIa4YbBMGQX7dBbYwRKx.AmQ3sJ8Ta5wYHh8a7jPlYDbNgMSD/hC<br>match result:true<br>encryptPassword:$2a$10$VryRC1lFaTEqUbOUyvu18ulSSGH5hK7JPzAG17ehtkL8aV6fot1ru<br>match result:true<br>encryptPassword:$2a$10$0SVRXbfgsqMvpmNDeeqNl.eFPvQ0ojdazk5.x8YDZxIOOP1D4xXge<br>match result:true<br>encryptPassword:$2a$10$yWdI4q6DXDZhknTxiT/9ROdhcAARAEY5q4L2YI5uQ3C52Q7Lt/IAa<br>match result:true<br>encryptPassword:$2a$10$8yy0.NdQSD2Cig5yIri2eu1XmDRpZSPjsmxDyRg9CZ5afwp/36H2S<br>match result:true<br>encryptPassword:$2a$10$QTJpm3jYUCjAoHPVI/uon.FDusm.9tPSc.mk6m.l/kx8aKbIzov3i<br>match result:true<br>encryptPassword:$2a$10$CkoGrZqDE86LM1yiX89cpuNDAMdDqemEKMSS3/jquFsxocizgBbX2<br>match result:true<br>encryptPassword:$2a$10$6M0N6cQp6kKeXgRl8ftqyOlikAV9YwfMS93xlqTXbd/tmDjFDv3iG<br>match result:true<br>encryptPassword:$2a$10$LboMUNAF7vOmucxJI3G/w.cliDRxH1exOmsfy2IlPCUpZU8N7XoO.<br>match result:true<br>encryptPassword:$2a$10$ezB0okY.JHv1gt4Y3chiu.5e5R9.vXqd7kNaYH14Vigm9wZ02D8Pe<br>match result:true<br>以上代码就是BCryptPassword的代码简单效果示例，相同的明文，每次生成的密文都是不同的，但是和明文做密码校验都是通过的。<br>还有一个就是密码字段的长度，如果打算采用bcrypt加密存储，字段长度不得低于60.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SpringSecurity之加密篇—BCryptpassword类&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;要点概括&lt;br&gt;BCryptpassword类是SpringSecurity的加密工具，封装了对密码混淆加密的方法，主要是采用盐（salt）对原始密码进行混淆。&lt;br&gt;本篇介绍的
      
    
    </summary>
    
    
      <category term="spring" scheme="http://pengw00.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate</title>
    <link href="http://pengw00.github.io/2019/04/02/Hibernate/"/>
    <id>http://pengw00.github.io/2019/04/02/Hibernate/</id>
    <published>2019-04-02T04:00:27.000Z</published>
    <updated>2019-04-02T04:03:59.330Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Hibernate的工作原理是什么？为什么要用hibernate？</li></ol><p>（1）Hibernate可以理解为一个中间件。它负责把java程序的SQL语句接收过来并发送到数据库，而数据库返回的信息由Hibernate接收后直接生成一个对象传给java.</p><p>在Hibernate中有两个特有的文件，一个是以.hbm.xml结尾的映射文件，一个是以.cfg.xml结尾的配置文件。.cfg.xml文件的作用是连接数据库，文件内部其实就是一个由user,password，url,driver组成的链接库的基本信息。.hbm.xml文件是对数据库中表的映射文件。</p><p>（2）Hibernate工作原理</p><p>①读取并解析hibernate.cfg.xml配置文件；</p><p>②由hibernate.cfg.xml中的<mapping resource="com/xx/user.hbm.xml">读取并解析映射信息；</mapping></p><p>③.通过SessionFactory sf = config.buildSessionFactory();创建SessionFactory</p><p>④Session session = sf.openSession();//打开Sesssion</p><p>⑤Transaction tx = session.beginTransaction();//创建并启动事务Transation</p><p>⑥persistent operate操作数据，持久化操作</p><p>⑦tx.commit();//提交事务</p><p>⑧关闭Session</p><p>⑨关闭SesstionFactory</p><p>3）使用Hibernate的原因如下：</p><p>① 对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。</p><p>②HIbernate是基于JDBC的主流持久化框架，是一个优秀的对象关系映射实现，它在很大程度上简化了DAO层的编码工作；</p><p>③Hibernate使用java反射机制，而不是字节码增强程序来实现透明性；</p><h2 id="④Hibernate性能非常好，因为它是一个轻量级框架，映射的灵活性很出色，它支持各种关系数据库，从一对一到多对多的各种复杂关系。"><a href="#④Hibernate性能非常好，因为它是一个轻量级框架，映射的灵活性很出色，它支持各种关系数据库，从一对一到多对多的各种复杂关系。" class="headerlink" title="④Hibernate性能非常好，因为它是一个轻量级框架，映射的灵活性很出色，它支持各种关系数据库，从一对一到多对多的各种复杂关系。"></a>④Hibernate性能非常好，因为它是一个轻量级框架，映射的灵活性很出色，它支持各种关系数据库，从一对一到多对多的各种复杂关系。</h2><p>为什么要持久化？ 持久化技术封装了数据访问细节，为大部分业务逻辑提供面向对象的API。 ● 通过持久化技术可以减少访问数据库数据次数，增加应用程序执行速度； ● 代码重用性高，能够完成大部分数据库操作； ● 松散耦合，使持久化不依赖于底层数据库和上层业务逻辑实现，更换数据库时只需修改配置文件而不用修改代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;Hibernate的工作原理是什么？为什么要用hibernate？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（1）Hibernate可以理解为一个中间件。它负责把java程序的SQL语句接收过来并发送到数据库，而数据库返回的信息由Hibernate接收后直接生成一个对象传给
      
    
    </summary>
    
    
      <category term="hibernate" scheme="http://pengw00.github.io/tags/hibernate/"/>
    
  </entry>
  
  <entry>
    <title>被amazon开出两次的经验总结</title>
    <link href="http://pengw00.github.io/2019/03/30/%E8%A2%ABamazon%E5%BC%80%E5%87%BA%E4%B8%A4%E6%AC%A1%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    <id>http://pengw00.github.io/2019/03/30/被amazon开出两次的经验总结/</id>
    <published>2019-03-30T19:04:14.000Z</published>
    <updated>2019-03-30T19:18:27.437Z</updated>
    
    <content type="html"><![CDATA[<p>1.政治斗争： fight all days, impossible to work</p><ol start="2"><li>status: hardworking, burn the middnight oil</li></ol><p>收获： 学会了亚马逊的生存法则<br>为什么离开： 需要pip， ？？<br>进去三个月被dev， 第二次因为组里launch新的项目，没有和其他组员抢活，被安排做operating&amp;&amp; bug之类的活，导致没有大项目来support 年度review</p><ol start="2"><li>把项目技术挖深了，确保工作安全。<br>和老板沟通，确定目前最重要的活是什么，focus在老板最关心的活上。确定掌握核心资源的是谁，积极主动去合作，拿可见度最高的活儿。</li><li>学会说不，组里同事塞给你，一般是知道是坑，学会优雅避开，比如我觉得xxx优先级比较高，我先focus on做完x，别的组找你帮忙，尽量给点帮助，别花太多时间，如果需要花很多时间，赵老板，老板会帮你退掉。<br>4.留证据<br>每周把做过的事给老板总结，要feedback，可以提高自己，也可以留证据，别人要开你的话，你都有wittern证据。</li><li><p>别的组问问题，不要给书面承诺，比如我会帮你debug之类，第一对方可能得寸进尺。第二，等别人要你帮忙的时候你可能没时间了真，问别人组的问题，尽量要书面email node， 或者可以开个简会马上把meeting note发出来，没人能赖账。 </p></li><li><p>后来加一点，能不去tech debt重的组就就尽量不去，天天修东西，没时间学习，没时间做项目。比如某语音助手的内核组。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.政治斗争： fight all days, impossible to work&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;status: hardworking, burn the middnight oil&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;收获： 学会了亚马逊的生存
      
    
    </summary>
    
    
      <category term="career" scheme="http://pengw00.github.io/tags/career/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 10 Regular expression</title>
    <link href="http://pengw00.github.io/2019/03/30/leetcode-10-Regular-expression/"/>
    <id>http://pengw00.github.io/2019/03/30/leetcode-10-Regular-expression/</id>
    <published>2019-03-30T18:22:18.000Z</published>
    <updated>2019-03-30T18:23:54.145Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode 10: Regular express</p><p>题目难理解。。。<em> 号match 0个或者以上的前字符，那不就是 a</em> 变成a或aa aaa aaaa</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;leetcode 10: Regular express&lt;/p&gt;
&lt;p&gt;题目难理解。。。&lt;em&gt; 号match 0个或者以上的前字符，那不就是 a&lt;/em&gt; 变成a或aa aaa aaaa&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://pengw00.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>March/30/2019 Study plan</title>
    <link href="http://pengw00.github.io/2019/03/30/March-30-2019-Study-plan/"/>
    <id>http://pengw00.github.io/2019/03/30/March-30-2019-Study-plan/</id>
    <published>2019-03-30T16:42:03.000Z</published>
    <updated>2019-03-30T19:18:30.894Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode:</p><ol><li>3 union find</li><li>3 dp </li><li>3 breadfirst search</li><li>binary index tree &amp; segment tree</li></ol><p>Resume: finish 4 project and get some stuff of the compony.</p><p>React: Redux review</p><p>System design one question: grokking the System design</p><p>Using formik library</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;leetcode:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;3 union find&lt;/li&gt;
&lt;li&gt;3 dp &lt;/li&gt;
&lt;li&gt;3 breadfirst search&lt;/li&gt;
&lt;li&gt;binary index tree &amp;amp; segment tree&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
    
      <category term="Study plan" scheme="http://pengw00.github.io/tags/Study-plan/"/>
    
  </entry>
  
  <entry>
    <title>react factory and functional component</title>
    <link href="http://pengw00.github.io/2019/03/30/react-factory-and-functional-component/"/>
    <id>http://pengw00.github.io/2019/03/30/react-factory-and-functional-component/</id>
    <published>2019-03-30T16:33:07.000Z</published>
    <updated>2019-03-30T16:41:10.554Z</updated>
    
    <content type="html"><![CDATA[<p>React factory pattern: react.createClass();<br>functioal component only return component while it is opposite of factory pattern. can combination with Redux data flow.<br>such as container component and presental component, which is pretty much like factory pattern, but the data is connect to the redux status. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;React factory pattern: react.createClass();&lt;br&gt;functioal component only return component while it is opposite of factory pattern. can com
      
    
    </summary>
    
    
      <category term="React" scheme="http://pengw00.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>factory pattern</title>
    <link href="http://pengw00.github.io/2019/03/29/factory-pattern/"/>
    <id>http://pengw00.github.io/2019/03/29/factory-pattern/</id>
    <published>2019-03-29T17:56:22.000Z</published>
    <updated>2019-03-30T16:19:25.060Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Factory  react example:</span><br></pre></td></tr></table></figure><p>export default class SlideFactory {<br>    static build(data) {<br>        switch (data.source) {<br>            case ‘brand’:<br>                return <brandfeedslide slidedata="{data}/">;<br>            case ‘article’:<br>                return <articlefeedslide slidedata="{data}">;<br>            default:<br>                return undefined;<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">const  items = [</span><br><span class="line">   &#123;    </span><br><span class="line">          source: ‘brand’,</span><br><span class="line">        title: ‘title’</span><br><span class="line">   &#125;    </span><br><span class="line">]</span><br><span class="line">const renderedItems = items.map((item) =&gt; SlideFactory.build(item));</span><br></pre></td></tr></table></figure></articlefeedslide></brandfeedslide></p><p>the items can have properties for different kinds of slider. </p><p>// A design without factory pattern </p><p>#include <iostream><br>using namespace std; </iostream></p><p>// Library classes<br>class Vehicle {<br>public:<br>    virtual void printVehicle() = 0;<br>};<br>class TwoWheeler : public Vehicle {<br>public:<br>    void printVehicle()  {<br>        cout &lt;&lt; “I am two wheeler” &lt;&lt; endl;<br>    }<br>};<br>class FourWheeler : public Vehicle {<br>    public:<br>    void printVehicle()  {<br>        cout &lt;&lt; “I am four wheeler” &lt;&lt; endl;<br>    }<br>}; </p><p>// Client (or user) class<br>class Client {<br>public:<br>    Client(int type)  { </p><pre><code>    // Client explicitly creates classes according to type     if (type == 1)         pVehicle = new TwoWheeler();     else if (type == 2)         pVehicle = new FourWheeler();     else        pVehicle = NULL; } ~Client()   {     if (pVehicle)     {         delete[] pVehicle;         pVehicle = NULL;     } } Vehicle* getVehicle() {     return pVehicle; } </code></pre><p>private:<br>    Vehicle *pVehicle;<br>}; </p><p>// Driver program<br>int main() {<br>    Client <em>pClient = new Client(1);<br>    Vehicle </em> pVehicle = pClient-&gt;getVehicle();<br>    pVehicle-&gt;printVehicle();<br>    return 0;<br>    }<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> What is the problems with above design?</span><br><span class="line">As you must have observed in the above example, Client creates objects of either TwoWheeler or FourWheeler based on some input during constructing its object.</span><br><span class="line">Say, library introduces a new class ThreeWheeler to incorporate three wheeler vehicles also. What would happen? Client will end up chaining a new else if in the conditional ladder to create objects of ThreeWheeler. Which in turn will need Client to be recompiled. So, each time a new change is made at the library side, Client would need to make some corresponding changes at its end and recompile the code. Sounds bad? This is a very bad practice of design.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">How to avoid the problem?</span><br><span class="line">The answer is, create a static (or factory) method. Let us see below code.</span><br></pre></td></tr></table></figure></p><p>// C++ program to demonstrate factory method design pattern </p><p>#include <iostream><br>using namespace std; </iostream></p><p>enum VehicleType {<br>    VT_TwoWheeler,    VT_ThreeWheeler,    VT_FourWheeler<br>}; </p><p>// Library classes<br>class Vehicle {<br>public:<br>    virtual void printVehicle() = 0;<br>    static Vehicle* Create(VehicleType type);<br>};<br>class TwoWheeler : public Vehicle {<br>public:<br>    void printVehicle() {<br>        cout &lt;&lt; “I am two wheeler” &lt;&lt; endl;<br>    }<br>};<br>class ThreeWheeler : public Vehicle {<br>public:<br>    void printVehicle() {<br>        cout &lt;&lt; “I am three wheeler” &lt;&lt; endl;<br>    }<br>};<br>class FourWheeler : public Vehicle {<br>    public:<br>    void printVehicle() {<br>        cout &lt;&lt; “I am four wheeler” &lt;&lt; endl;<br>    }<br>}; </p><p>// Factory method to create objects of different types.<br>// Change is required only in this function to create a new object type<br>Vehicle* Vehicle::Create(VehicleType type) {<br>    if (type == VT_TwoWheeler)<br>        return new TwoWheeler();<br>    else if (type == VT_ThreeWheeler)<br>        return new ThreeWheeler();<br>    else if (type == VT_FourWheeler)<br>        return new FourWheeler();<br>    else return NULL;<br>} </p><p>// Client class<br>class Client {<br>public: </p><pre><code>// Client doesn&apos;t explicitly create objects // but passes type to factory method &quot;Create()&quot; Client() {     VehicleType type = VT_ThreeWheeler;     pVehicle = Vehicle::Create(type); } ~Client() {     if (pVehicle) {         delete[] pVehicle;         pVehicle = NULL;     } } Vehicle* getVehicle()  {     return pVehicle; } </code></pre><p>private:<br>    Vehicle *pVehicle;<br>}; </p><p>// Driver program<br>int main() {<br>    Client <em>pClient = new Client();<br>    Vehicle </em> pVehicle = pClient-&gt;getVehicle();<br>    pVehicle-&gt;printVehicle();<br>    return 0;<br>}<br><code>`</code></p><p>In the above example, we have totally decoupled the selection of type for object creation from Client. The library is now responsible to decide which object type to create based on an input. Client just needs to make call to library’s factory Create method and pass the type it wants without worrying about the actual implementation of creation of objects.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
    
      <category term="Design pattern" scheme="http://pengw00.github.io/tags/Design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>Design high quality React component</title>
    <link href="http://pengw00.github.io/2019/03/28/Design-high-quality-React-component/"/>
    <id>http://pengw00.github.io/2019/03/28/Design-high-quality-React-component/</id>
    <published>2019-03-28T15:55:48.000Z</published>
    <updated>2019-03-29T17:56:02.634Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Design-high-quality-React-component"><a href="#Design-high-quality-React-component" class="headerlink" title="Design high quality React component"></a>Design high quality React component</h1><p>作为一个合格的开发者，不要只满足于编写了可以运行的代码。而要了解代码背后的工作原理；不要只满足于自己的程序能够运行，还要让自己的代码可读而且易于维护。这样才能开发出高质量的软件.</p><h2 id="构建高质量React组件的原则和方法"><a href="#构建高质量React组件的原则和方法" class="headerlink" title="构建高质量React组件的原则和方法"></a>构建高质量React组件的原则和方法</h2><pre><code>### 划分组件边界的原则 ###### React组件的数据种类 ###### React组件的生命周期 ###</code></pre><p>React组件设计的基础知识，因为React应用都是围绕组件的设计，所以关于组件的设计介绍将贯穿全书.</p><p>我会继续用react，四点理由：第一，“继续”说明我17年就在用react，最熟悉。虽然vue我也熟悉，毕竟放了一年了。angular我确实不太熟悉。第二，react生态现在确实非常好。而且前端生态的下一步进展（全链路，设计开发打通，组件市场，在线ide什么的），目前看来基于react的探索居多，未来会有技术红利。第三，不得不承认jsx真是好用，模板scope和js scope合一，而且可以面向过程任意分解render函数。不得不说，jsx的设计思想我当时花了几个月才真正理解其高明。第四，react有一个3k大小的小兄弟叫preact，这个非常有用。因为我们有时候希望把组件打包成不依赖任何框架的内嵌模块发布，但是把框架打包进去，会很大。这时把组件适配到preact，把preact打包进去就好了。<br>作者：匿名用户<br>链接：<a href="https://www.zhihu.com/question/266823404/answer/409100494" target="_blank" rel="noopener">https://www.zhihu.com/question/266823404/answer/409100494</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Design-high-quality-React-component&quot;&gt;&lt;a href=&quot;#Design-high-quality-React-component&quot; class=&quot;headerlink&quot; title=&quot;Design high quality Re
      
    
    </summary>
    
    
      <category term="React" scheme="http://pengw00.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>props and state new example</title>
    <link href="http://pengw00.github.io/2019/03/28/props-and-state-new-example/"/>
    <id>http://pengw00.github.io/2019/03/28/props-and-state-new-example/</id>
    <published>2019-03-28T14:08:40.000Z</published>
    <updated>2019-03-28T14:29:45.505Z</updated>
    
    <content type="html"><![CDATA[<p>[转载]<a href="https://www.jianshu.com/p/3cb5026edee8" target="_blank" rel="noopener">https://www.jianshu.com/p/3cb5026edee8</a></p><ol><li><p>props传值，直接在组件初始化的时候赋予参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;script src=&quot;https://zhangpeiyue.com/wp-content/uploads/2018/08/react.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;https://zhangpeiyue.com/wp-content/uploads/2018/08/react-dom.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;https://zhangpeiyue.com/wp-content/uploads/2018/08/babel.min_.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;wrap&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">    class MyComponent extends React.Component &#123;</span><br><span class="line">        //此处的构造器是可以省略的</span><br><span class="line">        constructor(props)&#123;</span><br><span class="line">            super(props);</span><br><span class="line">        &#125;</span><br><span class="line">        render() &#123;</span><br><span class="line">            return &lt;div&gt;好神奇！ &#123;this.props.siteName&#125;!&lt;/div&gt;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var element = &lt;MyComponent siteName=&quot;zhangpeiyue.com&quot;/&gt;;</span><br><span class="line">    ReactDOM.render(</span><br><span class="line">        element,</span><br><span class="line">        document.querySelector(&quot;#wrap&quot;)</span><br><span class="line">    );</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p>通过defaltProps 添加默认的props</p></li></ol><p>defaultProps是一个对象，放添加的值到defaultProps的属性中即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        //此处返回   &lt;div&gt;小张今年18岁了&lt;/div&gt;</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">            &#123;this.props.userName&#125;今年&#123;this.props.age&#125;岁了！</span><br><span class="line">        &lt;/div&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//为组件添加默认属性 userName与age</span><br><span class="line">MyComponent.defaultProps=&#123;</span><br><span class="line">    userName:&quot;小张&quot;,</span><br><span class="line">    age:18</span><br><span class="line">&#125;</span><br><span class="line">var element = &lt;MyComponent/&gt;;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    element,</span><br><span class="line">    document.querySelector(&quot;#wrap&quot;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><ol start="3"><li>可以通过父组件设置state，然后子组件通过props接收父组件的state值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//父组件</span><br><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        super();</span><br><span class="line">        //设置sate,添加name与age属性</span><br><span class="line">        this.state=&#123;</span><br><span class="line">            name:&quot;张培跃&quot;,</span><br><span class="line">            age:18</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">            &lt;Name name=&#123;this.state.name&#125;/&gt;</span><br><span class="line">            &lt;Age age=&#123;this.state.age&#125;/&gt;</span><br><span class="line">        &lt;/div&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//子组件Name</span><br><span class="line">class Name extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return &lt;div&gt;&#123;this.props.name&#125;&lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//子组件Age</span><br><span class="line">class Age extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return &lt;div&gt;&#123;this.props.age&#125;&lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var element = &lt;MyComponent/&gt;;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    element,</span><br><span class="line">    document.querySelector(&quot;#wrap&quot;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ol><p>4.使用propTypes进行类型检测</p><p>React提供了可以对Props进行验证的功能PropTypes。PropTypes为组件类自身的属性，提供了很多验证器，来验证传入的数据是否有效。当传入的数据无效时，JavaScript控制台会抛出警告。<br>另外需要注意的是，在开发环境下，当你使用了一个无效的值作为prop时，控件台会出现警告;在生产环境下，为了性能考虑会将PropTypes忽略掉！<br>要想使用propTypes,首先要对prop-type.js文件进行引入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://zhangpeiyue.com/wp-content/uploads/2018/08/prop-types.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>Example<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var name=&quot;老大&quot;</span><br><span class="line">var age=18;</span><br><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">            &#123;this.props.name&#125;今年&#123;this.props.age&#125;岁了！</span><br><span class="line">        &lt;/div&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//propTypes是组件类的静态属性</span><br><span class="line">MyComponent.propTypes=&#123;</span><br><span class="line">    //将name设置为string类型</span><br><span class="line">    name:PropTypes.string,</span><br><span class="line">    //将age设置为number类型</span><br><span class="line">    age:PropTypes.number</span><br><span class="line">&#125;;</span><br><span class="line">var element = &lt;MyComponent name=&#123;name&#125; age=&#123;age&#125; /&gt;;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    element,</span><br><span class="line">    document.querySelector(&quot;#wrap&quot;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>以上示例当中的name与age不合法时，会弹出类型不符的警告！所以在项目开发中使用PropTypes进行对props的验证还是很有好处的！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">More Validator:</span><br><span class="line">MyComponent.propTypes = &#123;</span><br><span class="line">    // 可以声明 prop 为指定的 JS 基本数据类型，默认情况，这些数据是可选的</span><br><span class="line">   optionalArray: React.PropTypes.array,</span><br><span class="line">    optionalBool: React.PropTypes.bool,</span><br><span class="line">    optionalFunc: React.PropTypes.func,</span><br><span class="line">    optionalNumber: React.PropTypes.number,</span><br><span class="line">    optionalObject: React.PropTypes.object,</span><br><span class="line">    optionalString: React.PropTypes.string,</span><br><span class="line"> </span><br><span class="line">    // 可以被渲染的对象 numbers, strings, elements 或 array</span><br><span class="line">    optionalNode: React.PropTypes.node,</span><br><span class="line"> </span><br><span class="line">    //  React 元素</span><br><span class="line">    optionalElement: React.PropTypes.element,</span><br><span class="line"> </span><br><span class="line">    // 用 JS 的 instanceof 操作符声明 prop 为类的实例。</span><br><span class="line">    optionalMessage: React.PropTypes.instanceOf(Message),</span><br><span class="line"> </span><br><span class="line">    // 用 enum 来限制 prop 只接受指定的值。</span><br><span class="line">    optionalEnum: React.PropTypes.oneOf([&apos;News&apos;, &apos;Photos&apos;]),</span><br><span class="line"> </span><br><span class="line">    // 可以是多个对象类型中的一个</span><br><span class="line">    optionalUnion: React.PropTypes.oneOfType([</span><br><span class="line">      React.PropTypes.string,</span><br><span class="line">      React.PropTypes.number,</span><br><span class="line">      React.PropTypes.instanceOf(Message)</span><br><span class="line">    ]),</span><br><span class="line"> </span><br><span class="line">    // 指定类型组成的数组</span><br><span class="line">    optionalArrayOf: React.PropTypes.arrayOf(React.PropTypes.number),</span><br><span class="line"> </span><br><span class="line">    // 指定类型的属性构成的对象</span><br><span class="line">    optionalObjectOf: React.PropTypes.objectOf(React.PropTypes.number),</span><br><span class="line"> </span><br><span class="line">    // 特定 shape 参数的对象</span><br><span class="line">    optionalObjectWithShape: React.PropTypes.shape(&#123;</span><br><span class="line">      color: React.PropTypes.string,</span><br><span class="line">      fontSize: React.PropTypes.number</span><br><span class="line">    &#125;),</span><br><span class="line"> </span><br><span class="line">    // 任意类型加上 `isRequired` 来使 prop 不可空。</span><br><span class="line">    requiredFunc: React.PropTypes.func.isRequired,</span><br><span class="line"> </span><br><span class="line">    // 不可空的任意类型</span><br><span class="line">    requiredAny: React.PropTypes.any.isRequired,</span><br><span class="line"> </span><br><span class="line">    // 自定义验证器。如果验证失败需要返回一个 Error 对象。不要直接使用 `console.warn` 或抛异常，因为这样 `oneOfType` 会失效。</span><br><span class="line">    customProp: function(props, propName, componentName) &#123;</span><br><span class="line">      if (!/matchme/.test(props[propName])) &#123;</span><br><span class="line">        return new Error(&apos;Validation failed!&apos;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在我们来总结下,props与state的区别：</p><p>props是指组件间传递的一种方式，props自然也可以传递state。由于React的数据流是自上而下的，所以是从父组件向子组件进行传递；另外组件内部的this.props属性是只读的不可修改！<br>state是组件内部的状态（数据），不能够直接修改，必须要通过setState来改变值的状态，从而达到更新组件内部数据的作用。</p><p>props和state是经常要结合使用的，父组件的state可以转化为props来为子组件进行传值。在这种情况下，子组件接收的props是只读的，想要改变值，只能通过父组件的state对其进行更改。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[转载]&lt;a href=&quot;https://www.jianshu.com/p/3cb5026edee8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/3cb5026edee8&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;
      
    
    </summary>
    
    
      <category term="React" scheme="http://pengw00.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 924. Minimize Malware Spread</title>
    <link href="http://pengw00.github.io/2019/03/28/leetcode-924-Minimize-Malware-Spread/"/>
    <id>http://pengw00.github.io/2019/03/28/leetcode-924-Minimize-Malware-Spread/</id>
    <published>2019-03-28T13:32:41.000Z</published>
    <updated>2019-03-28T13:33:37.024Z</updated>
    
    <content type="html"><![CDATA[<p>Union Find and bfs and dfs</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Union Find and bfs and dfs&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://pengw00.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>props and constructor &amp;&amp; super sweetie</title>
    <link href="http://pengw00.github.io/2019/03/28/props-and-constructor-super-sweetie/"/>
    <id>http://pengw00.github.io/2019/03/28/props-and-constructor-super-sweetie/</id>
    <published>2019-03-28T04:57:36.000Z</published>
    <updated>2019-03-28T05:28:02.264Z</updated>
    
    <content type="html"><![CDATA[<p>Look at this post!</p><p><a href="https://www.cnblogs.com/faith3/p/9219446.html" target="_blank" rel="noopener">https://www.cnblogs.com/faith3/p/9219446.html</a><br><a href="https://www.jianshu.com/p/1b5e86c68458" target="_blank" rel="noopener">https://www.jianshu.com/p/1b5e86c68458</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Look at this post!&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/faith3/p/9219446.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>get and post differ&#39;s</title>
    <link href="http://pengw00.github.io/2019/03/28/get-and-post-differ-s/"/>
    <id>http://pengw00.github.io/2019/03/28/get-and-post-differ-s/</id>
    <published>2019-03-28T04:26:37.000Z</published>
    <updated>2019-03-28T04:31:16.323Z</updated>
    
    <content type="html"><![CDATA[<p>GET和POST两种基本请求方法的区别</p><p>最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数</p><p>你轻轻松松的给出了一个“标准答案”：</p><p>GET在浏览器回退时是无害的，而POST会再次提交请求。</p><p>GET产生的URL地址可以被Bookmark，而POST不可以。</p><p>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</p><p>GET请求只能进行url编码，而POST支持多种编码方式。</p><p>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</p><p>GET请求在URL中传送的参数是有长度限制的，而POST么有。</p><p>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</p><p>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</p><p>GET参数通过URL传递，POST放在Request body中。</p><p>让我们扒下GET和POST的外衣，坦诚相见吧！</p><p>GET和POST是什么？HTTP协议中的两种发送请求的方法。</p><p>HTTP是什么？HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。</p><p>HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。 </p><p>在我大万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。为了避免这种情况发生，交通规则HTTP诞生了。HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签（设置method为GET），而且要求把传送的数据放在车顶上（url中）以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩；也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。</p><p>但是，我们只看到HTTP对GET和POST参数的传送渠道（url还是requrest body）提出了要求。“标准答案”里关于参数大小的限制又是从哪来的呢？</p><p>在我大万维网世界中，还有另一个重要的角色：运输公司。不同的浏览器（发起http请求）和服务器（接受http请求）就是不同的运输公司。 虽然理论上，你可以在车顶上无限的堆货物（url中无限加参数）。但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。</p><p>好了，现在你知道，GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</p><p>我们的大BOSS还等着出场呢。。。</p><p>这位BOSS有多神秘？当你试图在网上找“GET和POST的区别”的时候，那些你会看到的搜索结果里，从没有提到他。他究竟是什么呢。。。</p><p>GET和POST还有一个重大区别，简单的说：</p><p>GET产生一个TCP数据包；POST产生两个TCP数据包。</p><p>长的说：</p><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p><p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p><p>也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。</p><p>因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？</p><ol><li><p>GET与POST都有自己的语义，不能随便混用。</p></li><li><p>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</p></li><li><p>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</p></li></ol><p>现在，当面试官再问你“GET与POST的区别”的时候，你的内心是不是这样的？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;GET和POST两种基本请求方法的区别&lt;/p&gt;
&lt;p&gt;最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数&lt;/p&gt;
&lt;p&gt;你轻轻松松的给出了一个“标准答案”：&lt;/p&gt;
&lt;p&gt;GET在浏览器回退时是无害的，而POST会再次提交请求。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="http" scheme="http://pengw00.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>React Props and State</title>
    <link href="http://pengw00.github.io/2019/03/27/React-Props-and-State/"/>
    <id>http://pengw00.github.io/2019/03/27/React-Props-and-State/</id>
    <published>2019-03-28T03:12:33.000Z</published>
    <updated>2019-03-28T04:16:35.340Z</updated>
    
    <content type="html"><![CDATA[<p>@octocat :+1: Props looks great - it’s ready to mount! :shipit:</p><p>#</p><p>###The data in React flows from top to down(parent to child) and store in Props and state, when flow between cpmponnets it is in Props while in the component inside it is in the component. </p><p>###Props: for a component, it can acepts some params from outside, which is so called Props(either from parents or store). </p><p>###Property of Props: props used to decrate the component, so when the component is initialed and got instance, the props is unchangable and readable only. because when the props is changed during mounting the componet, if the props is changed, the component will be unpreditable.<br>所以只有通过父组件渲染方式才可以把props传进去。<br>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import Item from &quot;./item&quot;;</span><br><span class="line">export default class ItemList extends React.Component&#123;</span><br><span class="line">  const itemList = data.map(item =&gt; &lt;Item item=item /&gt;);</span><br><span class="line">  render()&#123;</span><br><span class="line">    return (</span><br><span class="line">      &#123;itemList&#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>In the child Component:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export default class Item extends React.Component&#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;li&gt;&#123;this.props.item&#125;&lt;/li&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在render函数中可以看出，组件内部是使用this.props来获取传递到该组件的所有数据，它是一个对象，包含了所有你对这个组件的配置，现在只包含了一个item属性，所以通过this.props.item来获取即可。</p><p>默认参数<br>在组件中，我们最好为props中的参数设置一个defaultProps，并且制定它的类型。比如，这样：</p><p>##总结：props是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的props来重新渲染子组件，否则子组件的props以及展现形式不会改变。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Item.defaultProps = &#123;</span><br><span class="line">  item: &apos;Hello Props&apos;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Item.propTypes = &#123;</span><br><span class="line">  item: PropTypes.string,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>关于propTypes，可以声明为以下几种类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">optionalArray: PropTypes.array,</span><br><span class="line">optionalBool: PropTypes.bool,</span><br><span class="line">optionalFunc: PropTypes.func,</span><br><span class="line">optionalNumber: PropTypes.number,</span><br><span class="line">optionalObject: PropTypes.object,</span><br><span class="line">optionalString: PropTypes.string,</span><br><span class="line">optionalSymbol: PropTypes.symbol,</span><br></pre></td></tr></table></figure></p><h2 id="what-about-state-State-is-similar-to-props-but-it-is-private-and-fully-controlled-by-the-component"><a href="#what-about-state-State-is-similar-to-props-but-it-is-private-and-fully-controlled-by-the-component" class="headerlink" title="what about state?? State is similar to props, but it is private and fully controlled by the component."></a>what about state?? State is similar to props, but it is private and fully controlled by the component.</h2><p>###一个组件的显示形态可以由数据状态和外部参数所决定，外部参数也就是props，而数据状态就是state<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">export default class ItemList extends React.Component&#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      itemList:&apos;一些数据&apos;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return (</span><br><span class="line">      &#123;this.state.itemList&#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先，在组件初始化的时候，通过this.state给组件设定一个初始的state，在第一次render的时候就会用这个数据来渲染组件。</p><p>state不同于props的一点是，state是可以被改变的。不过，不可以直接通过this.state=的方式来修改，而需要通过this.setState()方法来修改state。</p><p>比如，我们经常会通过异步操作来获取数据，我们需要在didMount阶段来执行异步操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  fetch(&apos;url&apos;)</span><br><span class="line">    .then(response =&gt; response.json())</span><br><span class="line">    .then((data) =&gt; &#123;</span><br><span class="line">      this.setState(&#123;itemList:item&#125;);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setState接受一个对象或者函数作为第一个参数，只需要传入需要更新的部分即可，不需要传入整个对象，比如:<br><figure class="highlight plain"><figcaption><span>default class ItemList extends React.Component&#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      name:&apos;axuebin&apos;,</span><br><span class="line">      age:25,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount()&#123;</span><br><span class="line">    this.setState(&#123;age:18&#125;)  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在执行完setState之后的state应该是{name:’axuebin’,age:18}。</p><p>setState还可以接受第二个参数，它是一个函数，会在setState调用完成并且组件开始重新渲染时被调用，可以用来监听渲染是否完成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.setState(&#123;</span><br><span class="line">  name:&apos;xb&apos;</span><br><span class="line">&#125;,()=&gt;console.log(&apos;setState finished&apos;))</span><br></pre></td></tr></table></figure></p><p>##总结<br>state的主要作用是用于组件保存、控制以及修改自己的状态，它只能在constructor中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的this.setState来修改，修改state属性会导致组件的重新渲染</p><p>##Summary</p><p>###1.state是组件自己管理数据，控制自己的状态，可变；</p><p>###2.props是外部传入的数据参数，不可变；</p><p>###3.没有state的叫做无状态组件，有state的叫做有状态组件；</p><p>###4.多用props，少用state。也就是多写无状态组件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@octocat :+1: Props looks great - it’s ready to mount! :shipit:&lt;/p&gt;
&lt;p&gt;#&lt;/p&gt;
&lt;p&gt;###The data in React flows from top to down(parent to chi
      
    
    </summary>
    
    
      <category term="React" scheme="http://pengw00.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>JavaBeans Definition</title>
    <link href="http://pengw00.github.io/2018/12/23/JavaBeans/"/>
    <id>http://pengw00.github.io/2018/12/23/JavaBeans/</id>
    <published>2018-12-24T00:24:58.000Z</published>
    <updated>2018-12-24T01:32:21.363Z</updated>
    
    <content type="html"><![CDATA[<p>Definition:<br>JavaBean 是一种JAVA语言写成的可重用组件。为写成JavaBean，类必须是具体的和公共的，并且具有无参数的构造器。JavaBean 通过提供符合一致性设计模式的公共方法将内部域暴露成员属性，long和class方法获取。众所周知，属性名称符合这种模式，其他Java 类可以通过自省机制发现和操作这些JavaBean 的属性。</p><p>Description:<br>JavaBean在MVC设计模型中是model，又称模型层，在一般的程序中，我们称它为数据层，就是用来设置数据的属性和一些行为，然后我会提供获取属性和设置属性的get/set方法.</p><p>MVC:<br>MVC的概念，即M-model-模型：JavaBean；V-view-表现：JSP页面；C-control-控制和处理：Servlet.</p><p>Disadvantage:<br>1.提高代码的可复用性：对于通用的事务处理逻辑，数据库操作等都可以封装在JavaBean中，通过调用JavaBean的属性和方法可快速进行程序设计。<br>    2.程序易于开发维护：实现逻辑的封装，使事务处理和显示互不干扰。<br>    3.支持分布式运用：多用JavaBean，尽量减少java代码和html的混编。<br>    4.可以便捷地传递数据</p><p>Rule: Javabean类必须是public类 2、提供给JSP页面的调用方法必须富裕public访问权限 3、bean中属性必须给get和set方法 4、必须由空构造方法.</p><p>Example: </p><p>package Server;</p><p>import java.io.Serializable;<br>public class Product implements Serializable<br>{<br>    private static final long serialVersionUID = 1L;<br>    private String product_id;<br>    private String product_name;<br>    private double price;<br>    private String info;</p><pre><code>public Product(){    super();}public void setPrice(double price) {    this.price = price;}public double getPrice() {    return price;}public void setInfo(String info) {    this.info = info;}public String getInfo() {    return info;}public void setProduct_id(String product_id) {    this.product_id = product_id;}public String getProduct_id() {    return product_id;}public void setProduct_name(String product_name) {    this.product_name = product_name;}public String getProduct_name() {    return product_name;}</code></pre><p>}<br>Example Usage: </p><p>在页面中要导入相应的Bean类，并用<a href="jsp:usebean" target="_blank" rel="noopener">jsp:usebean</a>标签获取Bean对象<br>＜jsp:useBean id=”自定义该Bean名字” class=”Bean类位置” scope=”Bean有效范围”/＞<br>Bean有效范围：page、request、session、application<br>设置Bean属性<a href="jsp:setProperty" target="_blank" rel="noopener">jsp:setProperty</a>，获取Bean属性<a href="jsp:getProperty" target="_blank" rel="noopener">jsp:getProperty</a><br>&lt;jsp:setProperty name=”Bean的id” property=”Bean类属性名” param=”表单参数名”/&gt;<br>&lt;jsp:getProperty property=”Bean类属性名” name=”Bean的id”/&gt;</p><p>Example:<br>&lt;%@ page language=”java” contentType=”text/html; charset=utf-8”<br>    pageEncoding=”utf-8”%&gt;<br>&lt;%@ page import=”java.util.*” %&gt;<br>&lt;%request.setCharacterEncoding(“utf-8”); %&gt;<br>&lt;jsp:useBean id=”product” class=”Server.Product” scope=”page” /&gt;<br>&lt;!DOCTYPE html PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN” “<a href="http://www.w3.org/TR/html4/loose.dtd&quot;&gt;" target="_blank" rel="noopener">http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</a></p><html><br><head><meta name="generator" content="Hexo 3.8.0"><br><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><br><title>通过表单参数设置Bean属性值</title><br></head><br><body><br><form action method="post"><br><br><br>输入产品名称：<input type="text" name="product_name"><br><br>输入产品编号：<input type="text" name="product_id"><br><br>输入产品价格：<input type="text" name="price"><br><br>输入产品信息：<input type="text" name="info"><br><br><input type="submit" value="提交"><br></form><br><!-- 设置product名称 --><br>&lt;jsp:setProperty property=”product_name” name=”product” value=”struts开发教程”/&gt;<br><br>产品名称是：<br><!-- 获取产品名称 --><br>&lt;jsp:getProperty property=”product_name” name=”product”/&gt;<br>&lt;%=product.getProduct_name() %&gt;<br><br><br><br><!-- 设置产品编号 --><br>&lt;jsp:setProperty property=”product_id” name=”product” value=”111100123689”/&gt;<br><br>产品编号是：<br><!-- 获取产品编号 --><br>&lt;jsp:getProperty property=”product_id” name=”product”/&gt;<br>&lt;%=product.getProduct_id() %&gt;<br><br><br><!-- 设置产品价格 --><br>&lt;%<br>double price=68.23;<br>%&gt;<br>&lt;jsp:setProperty property=”price” name=”product” value=”&lt;%=price +23.67%&gt;”/&gt;<br><br>产品价格是：<br><!-- 获取产品价格 --><br>&lt;jsp:getProperty property=”price” name=”product”/&gt;<br><br><br><br><!-- 设置产品信息 --><br>&lt;jsp:setProperty property=”info” name=”product” value=”Structs开发教程是一本介绍秿Struct的专业书籍….”/&gt;<br><br>产品信息：<br><!-- 获取产品信息 --><br>&lt;jsp:getProperty property=”info” name=”product”/&gt;<br></body><br></html><p>Cons:<br>其实所有的程序都可以写在jsp页面里，但是存在以下问题：<br>1、执行效率低下；<br>2、不安全，所有的程序都在jsp文件中可见，毫无知识保护可言；<br>3、逻辑混乱。这样让JSP文件的逻辑很难懂。<br>    于是提出了MVC模式，即将一些处理用的程序从JSP中分离出来，让JSP页面只负责显示，几乎是html，只不过可以动态的读取数据和进行少量的逻辑处理，比如循环、判断等。<br>    可能不举例说你还是不懂，我就举个最简单的例子——留言板。<br>    JSP的职责：从数据库取出数据，显示所有的留言信息（当中要用少量的，简单的逻辑处理：循环）、显示签写留言的页面（几乎全部都是html）。<br>    Servlet的职责：接受签写留言页面提交过来的标单数据，进行数据检验，如果正确，则存入数据库并返回留言的显示页面；如果数据有误，给出错误提示后返回签写留言的页面。可以看到，这个就叫做逻辑处理。这些你也完全可以放在JSP中实现，但是用Servlet，其效率和安全性高多了，也让JSP页面变得很简洁明了。<br>    JavaBean的职责：其实一般的留言板是不需要用到JavaBean的，但在这里，为了让你明白，还是牵强的把JavaBean用进来。所谓JavaBean，就是一个很简单的Java类，比如说，网上商城的所有商品是一个商品类，论坛中所有的帖子是一个帖子类，这里，留言板的所有留言是一个留言类，叫做Message类。每个类有着它特定的属性和方法。对于Message类，其属性有主题、内容、日期、留言者等，其方法可以有添加留言、删除留言、修改留言等。使用JavaBean，主要是为了让JSP编程能够适应Java程序员的习惯，直接对类和实例进行操作，而不是直接去操作数据库。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Definition:&lt;br&gt;JavaBean 是一种JAVA语言写成的可重用组件。为写成JavaBean，类必须是具体的和公共的，并且具有无参数的构造器。JavaBean 通过提供符合一致性设计模式的公共方法将内部域暴露成员属性，long和class方法获取。众所周知，属
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://pengw00.github.io/tags/Spring/"/>
    
  </entry>
  
</feed>
