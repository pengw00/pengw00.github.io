<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pengw00&#39;s Tech Road</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://pengw00.github.io/"/>
  <updated>2019-04-12T03:14:41.571Z</updated>
  <id>http://pengw00.github.io/</id>
  
  <author>
    <name>pengw00</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Jest</title>
    <link href="http://pengw00.github.io/2019/04/11/Jest/"/>
    <id>http://pengw00.github.io/2019/04/11/Jest/</id>
    <published>2019-04-11T13:56:24.000Z</published>
    <updated>2019-04-12T03:14:41.571Z</updated>
    
    <content type="html"><![CDATA[<p>Run:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add --dev react-test-renderer</span><br></pre></td></tr></table></figure></p><p>Setup without Create React App</p><p>If you have an existing application you’ll need to install a few packages to make everything work well together. We are using the babel-jest package and the react babel preset to transform our code inside of the test environment.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add --dev jest babel-jest @babel/preset-env @babel/preset-react react-test-renderer</span><br></pre></td></tr></table></figure><p>Example<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;react&quot;: &quot;&lt;current-version&gt;&quot;,</span><br><span class="line">    &quot;react-dom&quot;: &quot;&lt;current-version&gt;&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;@babel/preset-env&quot;: &quot;&lt;current-version&gt;&quot;,</span><br><span class="line">    &quot;@babel/preset-react&quot;: &quot;&lt;current-version&gt;&quot;,</span><br><span class="line">    &quot;babel-jest&quot;: &quot;&lt;current-version&gt;&quot;,</span><br><span class="line">    &quot;jest&quot;: &quot;&lt;current-version&gt;&quot;,</span><br><span class="line">    &quot;react-test-renderer&quot;: &quot;&lt;current-version&gt;&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;jest&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  // babel.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  presets: [&apos;@babel/preset-env&apos;, &apos;@babel/preset-react&apos;],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// Link.react.js</span><br><span class="line">import React from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">const STATUS = &#123;</span><br><span class="line">  HOVERED: &apos;hovered&apos;,</span><br><span class="line">  NORMAL: &apos;normal&apos;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default class Link extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line"></span><br><span class="line">    this._onMouseEnter = this._onMouseEnter.bind(this);</span><br><span class="line">    this._onMouseLeave = this._onMouseLeave.bind(this);</span><br><span class="line"></span><br><span class="line">    this.state = &#123;</span><br><span class="line">      class: STATUS.NORMAL,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _onMouseEnter() &#123;</span><br><span class="line">    this.setState(&#123;class: STATUS.HOVERED&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _onMouseLeave() &#123;</span><br><span class="line">    this.setState(&#123;class: STATUS.NORMAL&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;a</span><br><span class="line">        className=&#123;this.state.class&#125;</span><br><span class="line">        href=&#123;this.props.page || &apos;#&apos;&#125;</span><br><span class="line">        onMouseEnter=&#123;this._onMouseEnter&#125;</span><br><span class="line">        onMouseLeave=&#123;this._onMouseLeave&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        &#123;this.props.children&#125;</span><br><span class="line">      &lt;/a&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>example: </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Run:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pr
      
    
    </summary>
    
    
      <category term="React" scheme="http://pengw00.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>leetcode380InsertDeleteGetRandom</title>
    <link href="http://pengw00.github.io/2019/04/10/leetcode380InsertDeleteGetRandom/"/>
    <id>http://pengw00.github.io/2019/04/10/leetcode380InsertDeleteGetRandom/</id>
    <published>2019-04-10T16:16:16.000Z</published>
    <updated>2019-04-10T16:16:16.493Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>babel+gulp+ESlint</title>
    <link href="http://pengw00.github.io/2019/04/09/babel-gulp-ESlint/"/>
    <id>http://pengw00.github.io/2019/04/09/babel-gulp-ESlint/</id>
    <published>2019-04-10T01:12:05.000Z</published>
    <updated>2019-04-10T16:40:52.948Z</updated>
    
    <content type="html"><![CDATA[<p>Use Babel in Build tools<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save-dev gulp </span><br><span class="line">$ npm install --save-dev gulp-babel</span><br></pre></td></tr></table></figure></p><p>Following gulp code demonstrates how to compile all JS files in a src/js directory into ES5 JS files and output to a dist/js directory.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&quot;gulp&quot;);</span><br><span class="line">var babel = require(&quot;gulp-babel&quot;);</span><br><span class="line"></span><br><span class="line">gulp.task(&quot;default&quot;, function () &#123;</span><br><span class="line">    return gulp.src(&quot;src/js/*.js&quot;)</span><br><span class="line">        .pipe(babel())</span><br><span class="line">        .pipe(gulp.dest(&quot;dist/js&quot;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Use Babel in Build tools&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="JS" scheme="http://pengw00.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>stack&amp;calculator problem(recursive a little bit)</title>
    <link href="http://pengw00.github.io/2019/04/06/stack-calculator-problem-recursive-a-little-bit/"/>
    <id>http://pengw00.github.io/2019/04/06/stack-calculator-problem-recursive-a-little-bit/</id>
    <published>2019-04-06T06:57:25.000Z</published>
    <updated>2019-04-06T06:58:21.070Z</updated>
    
    <content type="html"><![CDATA[<h1 id="stack-amp-calculator-problem"><a href="#stack-amp-calculator-problem" class="headerlink" title="stack&amp;calculator problem"></a>stack&amp;calculator problem</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;stack-amp-calculator-problem&quot;&gt;&lt;a href=&quot;#stack-amp-calculator-problem&quot; class=&quot;headerlink&quot; title=&quot;stack&amp;amp;calculator problem&quot;&gt;&lt;/a&gt;st
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://pengw00.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>背包问题 </title>
    <link href="http://pengw00.github.io/2019/04/06/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E2%80%9C/"/>
    <id>http://pengw00.github.io/2019/04/06/背包问题“/</id>
    <published>2019-04-06T06:22:15.000Z</published>
    <updated>2019-04-06T06:23:11.634Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背包问题及dp"><a href="#背包问题及dp" class="headerlink" title="背包问题及dp"></a>背包问题及dp</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背包问题及dp&quot;&gt;&lt;a href=&quot;#背包问题及dp&quot; class=&quot;headerlink&quot; title=&quot;背包问题及dp&quot;&gt;&lt;/a&gt;背包问题及dp&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="http://pengw00.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>find celebrity</title>
    <link href="http://pengw00.github.io/2019/04/06/find-celebrity/"/>
    <id>http://pengw00.github.io/2019/04/06/find-celebrity/</id>
    <published>2019-04-06T04:42:24.000Z</published>
    <updated>2019-04-06T04:48:52.976Z</updated>
    
    <content type="html"><![CDATA[<p>这道题类似于997 find the town judge。<br>但可以采用graph的方法，topological的bfs方法，计算每个点的入度和出度，找出那个入读为n-1的就是解。<br>另一个种方法是find celebrity的方法，先定义i=0；遍历找出一个candidate， 再遍历判断是否这个candidate满足谁都认识他和他不认识任何人两个条件，如果可以100%确定就是他。<br>废话不说：coding：<br>方法1: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int findJudge(int N, vector&lt;vector&lt;int&gt;&gt;&amp; trust) &#123;</span><br><span class="line">  vector&lt;vector&lt;int&gt;&gt; knows(N + 1, vector&lt;int&gt;(N + 1));</span><br><span class="line">  for (auto &amp;t : trust) knows[t[0]][t[1]] = 1;</span><br><span class="line">  return findCelebrity(N, knows);</span><br><span class="line">&#125;</span><br><span class="line">int findCelebrity(int n, vector&lt;vector&lt;int&gt;&gt;&amp; knows, int i = 1) &#123;</span><br><span class="line">  for (auto j = i + 1; j &lt;= n; ++j) if (knows[i][j]) i = j;</span><br><span class="line">  for (auto j = 1; j &lt; i; ++j) if (knows[i][j]) return -1;</span><br><span class="line">  for (auto j = 1; j &lt;= n; ++j) if (i != j &amp;&amp; !knows[j][i]) return -1;</span><br><span class="line">  return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：<br>directed graph：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int findJudge(int N, vector&lt;vector&lt;int&gt;&gt;&amp; trust) &#123;</span><br><span class="line">        vector&lt;int&gt; count(N + 1, 0);</span><br><span class="line">        for (auto&amp; t : trust)</span><br><span class="line">            count[t[0]]--, count[t[1]]++;</span><br><span class="line">        for (int i = 1; i &lt;= N; ++i) &#123;</span><br><span class="line">            if (count[i] == N - 1) return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这道题类似于997 find the town judge。&lt;br&gt;但可以采用graph的方法，topological的bfs方法，计算每个点的入度和出度，找出那个入读为n-1的就是解。&lt;br&gt;另一个种方法是find celebrity的方法，先定义i=0；遍历找出一个ca
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://pengw00.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>viewEncasulation</title>
    <link href="http://pengw00.github.io/2019/04/04/viewEncasulation/"/>
    <id>http://pengw00.github.io/2019/04/04/viewEncasulation/</id>
    <published>2019-04-04T23:13:16.000Z</published>
    <updated>2019-04-04T23:13:16.379Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>babel and webpack</title>
    <link href="http://pengw00.github.io/2019/04/04/babel-and-webpack/"/>
    <id>http://pengw00.github.io/2019/04/04/babel-and-webpack/</id>
    <published>2019-04-04T18:23:42.000Z</published>
    <updated>2019-04-04T18:36:30.366Z</updated>
    
    <content type="html"><![CDATA[<p>#Babel and webpack</p><h2 id="Babel-is-Javacsript-compiler"><a href="#Babel-is-Javacsript-compiler" class="headerlink" title="Babel is Javacsript compiler."></a>Babel is Javacsript compiler.</h2><p>webpack is a module bundler. Its main purpose is to bundle JavaScript files for usage in a browser, yet it is also capable of transforming, bundling, or packaging ##</p><p>In this unit, you modify the existing application and use some new ECMAScript 6 features. You then set up a build environment using Babel and Webpack.</p><p>Step 1: using new ECMAScript 6 Features</p><p>in app.js with arrow functions and let %!#$!#</p><p>Step 2: Setup Babel and Webpack<br>install webpack and babel<br>in folder create webpack.config.js:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var path = require(&apos;path&apos;);</span><br><span class="line"> var webpack = require(&apos;webpack&apos;);</span><br><span class="line"> module.exports = &#123;</span><br><span class="line">     entry: &apos;./js/app.js&apos;,</span><br><span class="line">     output: &#123;</span><br><span class="line">         path: path.resolve(__dirname, &apos;build&apos;),</span><br><span class="line">         filename: &apos;app.bundle.js&apos;</span><br><span class="line">     &#125;,</span><br><span class="line">     module: &#123;</span><br><span class="line">         loaders: [</span><br><span class="line">             &#123;</span><br><span class="line">                 test: /\.js$/,</span><br><span class="line">                 loader: &apos;babel-loader&apos;,</span><br><span class="line">                 query: &#123;</span><br><span class="line">                     presets: [&apos;es2015&apos;]</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         ]</span><br><span class="line">     &#125;,</span><br><span class="line">     stats: &#123;</span><br><span class="line">         colors: true</span><br><span class="line">     &#125;,</span><br><span class="line">     devtool: &apos;source-map&apos;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></p><p> Step 4: </p><p> package.json in your favorite code editor. In the scripts section, add a script named webpack that builds your application using Webpack and Babel. The scripts section should now look like this:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;webpack&quot;: &quot;webpack&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;http-server&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><ol start="5"><li>Create build folder to the compile version of the application<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The build process will fail if you don’t create the build directory</span><br></pre></td></tr></table></figure></li></ol><p>Step next:  Build and Run</p><ol><li>npm run webpack</li></ol><p>open index.html modified the <script> tag to load the build/app.bundle.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;build/app.bundle.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p></script></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#Babel and webpack&lt;/p&gt;
&lt;h2 id=&quot;Babel-is-Javacsript-compiler&quot;&gt;&lt;a href=&quot;#Babel-is-Javacsript-compiler&quot; class=&quot;headerlink&quot; title=&quot;Babel is J
      
    
    </summary>
    
    
      <category term="Javascript" scheme="http://pengw00.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>js null vs undefined</title>
    <link href="http://pengw00.github.io/2019/04/04/js-null-vs-undefined/"/>
    <id>http://pengw00.github.io/2019/04/04/js-null-vs-undefined/</id>
    <published>2019-04-04T15:19:28.000Z</published>
    <updated>2019-04-04T15:33:14.220Z</updated>
    
    <content type="html"><![CDATA[<h1 id="null-vs-undefined"><a href="#null-vs-undefined" class="headerlink" title="null vs undefined"></a>null vs undefined</h1><p>What is null?<br>There are two features of null you should understand:</p><pre><code>null is an empty or non-existent value.null must be assigned.</code></pre><p>ex:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a = null;</span><br><span class="line">console.log(a);</span><br><span class="line">// null</span><br></pre></td></tr></table></figure></p><p>Undefined most typically means a variable has been declared, but not defined. For example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let b;</span><br><span class="line">console.log(b);</span><br><span class="line">// undefined</span><br><span class="line"></span><br><span class="line">let c = undefined;</span><br><span class="line">console.log(c);</span><br><span class="line">// undefined</span><br></pre></td></tr></table></figure></p><p>Finally, when looking up non-existent properties in an object, you will receive undefined:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var d = &#123;&#125;;</span><br><span class="line">console.log(d.fake);</span><br><span class="line">// undefined</span><br></pre></td></tr></table></figure></p><p>Here’s a full list for six falsy values:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">0 (zero)</span><br><span class="line">“” (empty string)</span><br><span class="line">null</span><br><span class="line">undefined</span><br><span class="line">NaN (Not A Number)</span><br></pre></td></tr></table></figure></p><p>Interestingly enough, when using typeof to test null, it returns object:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let a = null;</span><br><span class="line">let b;</span><br><span class="line">console.log(typeof a);</span><br><span class="line">// object</span><br><span class="line">console.log(typeof b);</span><br><span class="line">// undefined</span><br></pre></td></tr></table></figure></p><p>Null !== undefined<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">null !== undefined</span><br></pre></td></tr></table></figure></p><p>But, and this may surprise you, null loosely equals undefined.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">null == undefined</span><br></pre></td></tr></table></figure></p><p>a great example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let logHi = (str = &apos;hi&apos;) =&gt; &#123;</span><br><span class="line">  console.log(str);</span><br></pre></td></tr></table></figure></p><p>This function requires one parameter and sets the default of that parameter to hi if it isn’t supplied. Here’s what that looks like:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">logHi();</span><br><span class="line">// hi</span><br><span class="line">logHi(&apos;bye&apos;);</span><br><span class="line">// bye</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>With default parameters, undefined will use the default while null does not.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">logHi(undefined);</span><br><span class="line">// hi</span><br><span class="line">logHi(null);</span><br><span class="line">// null</span><br></pre></td></tr></table></figure></p><p>Summary<br>null is an assigned value. It means nothing.<br>undefined typically means a variable has been declared but not defined yet.<br>null and undefined are falsy values.<br>null and undefined are both primitives. However an error shows that typeof null = object.<br>null !== undefined but null == undefined.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;null-vs-undefined&quot;&gt;&lt;a href=&quot;#null-vs-undefined&quot; class=&quot;headerlink&quot; title=&quot;null vs undefined&quot;&gt;&lt;/a&gt;null vs undefined&lt;/h1&gt;&lt;p&gt;What is nu
      
    
    </summary>
    
    
      <category term="Javascript" scheme="http://pengw00.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>didmount&amp;&amp;willunmount</title>
    <link href="http://pengw00.github.io/2019/04/04/didmount-willunmount/"/>
    <id>http://pengw00.github.io/2019/04/04/didmount-willunmount/</id>
    <published>2019-04-04T14:21:11.000Z</published>
    <updated>2019-04-04T14:49:13.907Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">export default class A extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line">    scroll1（）&#123;&#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        window.addEventListener(&apos;scroll&apos;, this.srcoll1.bind(this));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    componentWillUnmount()&#123;</span><br><span class="line">        window.removeEventListener(&apos;scroll&apos;, this.srcoll1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>when using event handler in render(), need to bind this to the function<br>inside constructor, it will be global. otherwise, everytime inside render() we need to bind this when we use the method everytime, it will be awaste of time.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">export default class A extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.scroll1 = this.scroll1.bind(this)</span><br><span class="line">    &#125;</span><br><span class="line">    scroll1（）&#123;&#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        window.addEventListener(&apos;scroll&apos;, this.scroll1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    componentWillUnmount()&#123;</span><br><span class="line">        window.removeEventListener(&apos;scroll&apos;, this.scroll1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>bind方法，顾名思义，就是绑定的意思，到底是怎么绑定然后怎么用呢，下面就来说说我对这个方法的理解。</p><p>bind的使用和call，apply的区别：都是将方法的主人绑定，this指向全局object。<br>bind will not be executed imediately while call, aply will execute right away.<br>为什么要创建绑定函数，就是当我们调用某些函数的时候是要在特定环境下才能调用到，所以我们就要把函数放在特定环境下，就是使用bind把函数绑定到特定的所需的环境下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="React" scheme="http://pengw00.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>topological sort template</title>
    <link href="http://pengw00.github.io/2019/04/04/topological-sort-template/"/>
    <id>http://pengw00.github.io/2019/04/04/topological-sort-template/</id>
    <published>2019-04-04T04:46:18.000Z</published>
    <updated>2019-04-04T21:15:45.716Z</updated>
    
    <content type="html"><![CDATA[<p>2.怎么得出拓扑序？</p><p>有两种方法，分别基于BFS和DFS，时间复杂度都是O(|V| + |E|)。<br>Topological Sort: DFS and BFS<br>DFS:<br>据说这是神书《算法导论》中提到的算法：用深度搜索来遍历整个图，采用一个数组来保存每个顶点完成的时间，这样这个数组就存放了按先后顺序访问完成的顶点了。然后我们按照顶点访问的完成时间从大到小排序，得到的就是一个拓扑序了，具体证明如下（来自其他博客）：&amp;……%¥¥……&amp;&amp;</p><p>Coding:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; topologicalSort(int n, vector&lt;pair&lt;int, int&gt; &gt;&amp; edges) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        stack&lt;int&gt; s;</span><br><span class="line">        int * isVisited = new int[n];</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            isVisited[i] = 0;</span><br><span class="line">        &#125; </span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (!isVisited[i]) dfs(edges, s, isVisited, i);</span><br><span class="line">        &#125;</span><br><span class="line">        while (!s.empty()) &#123;</span><br><span class="line">            res.push_back(s.top());</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    void dfs(vector&lt;pair&lt;int, int&gt; &gt;&amp; edges, stack&lt;int&gt; &amp; s, int * isVisited, int u) &#123;</span><br><span class="line">        isVisited[u] = 1;</span><br><span class="line">        for (int i = 0; i &lt; edges.size(); i++) &#123;</span><br><span class="line">            if (edges[i].first == u &amp;&amp; !isVisited[edges[i].second]) &#123;</span><br><span class="line">                dfs(edges, s, isVisited, edges[i].second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.push(u);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>BFS:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; topologicalSort(int n, vector&lt;pair&lt;int, int&gt; &gt;&amp; edges) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; newedges(n, vector&lt;int&gt;());</span><br><span class="line">        queue&lt;int&gt; q;</span><br><span class="line">        vector&lt;int&gt; in_degree(n, 0);</span><br><span class="line">        for (int i = 0; i &lt; edges.size(); i++) &#123;</span><br><span class="line">            in_degree[edges[i].second]++;</span><br><span class="line">            newedges[edges[i].first].push_back(edges[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (in_degree[i] == 0) &#123;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            int front = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            res.push_back(front);</span><br><span class="line">            for (int i = 0; i &lt; newedges[front].size(); i++) &#123;</span><br><span class="line">                in_degree[newedges[front][i]]--;</span><br><span class="line">                if (in_degree[newedges[front][i]] == 0) q.push(newedges[front][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>4.抛开这道题目——有环情况的判断</p><p>可以利用上面的dfs方法，比如isVisited这个数组，我们可以多增一种情况，比如0为未访问，1为已访问，-1为正在访问，当dfs搜索时遇到了一条边终止顶点对应的isVisited元素为-1时，就说明图中有环了（为-1说明我们是从这个顶点开始dfs的，现在又遇到了这个顶点…）。</p><p>另外一种判断图是否有环的方法，借助bfs（dfs也可，但既然用了dfs，直接用上面的方法好了），假如“生成拓扑序”后，还有顶点不在这个“拓扑序”里面，则图就有环了（加双引号是因为不能真正称作“拓扑序”啊）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2.怎么得出拓扑序？&lt;/p&gt;
&lt;p&gt;有两种方法，分别基于BFS和DFS，时间复杂度都是O(|V| + |E|)。&lt;br&gt;Topological Sort: DFS and BFS&lt;br&gt;DFS:&lt;br&gt;据说这是神书《算法导论》中提到的算法：用深度搜索来遍历整个图，采用一个数
      
    
    </summary>
    
    
      <category term="algorithm" scheme="http://pengw00.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>路径选择的dp问题之三角形最小路径和</title>
    <link href="http://pengw00.github.io/2019/04/03/%E8%B7%AF%E5%BE%84%E9%80%89%E6%8B%A9%E7%9A%84dp%E9%97%AE%E9%A2%98%E4%B9%8B%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>http://pengw00.github.io/2019/04/03/路径选择的dp问题之三角形最小路径和/</id>
    <published>2019-04-04T03:16:36.000Z</published>
    <updated>2019-04-04T04:16:37.558Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://blog.csdn.net/xdzhangzhenhao/article/details/81356095" target="_blank" rel="noopener">https://blog.csdn.net/xdzhangzhenhao/article/details/81356095</a><br><a href="http://www.cnblogs.com/shizhh/p/5302852.html" target="_blank" rel="noopener">http://www.cnblogs.com/shizhh/p/5302852.html</a> 动态规划</p><ol start="120"><li>三角形最小路径和</li></ol><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p><p>例如，给定三角形：</p><p>[<br>     [2],<br>    [3,4],<br>   [6,5,7],<br>  [4,1,8,3]<br>]<br>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</p><p>如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分.暂时没想到。。。（可能是用in-place方法）可行。</p><p>这道题类似于hmm的路径中选择概率最大的乘织。<br>采用topdown的dp 方法，最顶端的点决定于左右下方两侧的点的minsum，不能采用bottomup的方法。因为可能出现local最优值。<br>思路是经过当前节点的最小路径为左右节点的路径的最小值加自身，从上往下递归（top down），如果从下往上选，这个思路将是错的，因为你的局部最小并不可以确定最优会经过这里，所以从源头定点开始。<br>采用递归的方法构造，minsum(trangle, 0, 0).<br>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution1 &#123;</span><br><span class="line"> </span><br><span class="line">private:</span><br><span class="line"> </span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; memo;</span><br><span class="line">//cache</span><br><span class="line">int m;// 行数</span><br><span class="line"> </span><br><span class="line">// i,j代表当前节点的索引</span><br><span class="line">int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; triangle, int i, int j) &#123;</span><br><span class="line"> </span><br><span class="line">if (i == m - 1)</span><br><span class="line">return triangle[i][j];</span><br><span class="line"> </span><br><span class="line">// 相同结构子问题的递归</span><br><span class="line">if (memo[i][j] == -1) &#123;</span><br><span class="line">memo[i][j] = min(minPathSum(triangle, i + 1, j), minPathSum(triangle, i + 1, j + 1)) + triangle[i][j];</span><br><span class="line">cout &lt;&lt;&quot;memo[&quot;&lt;&lt;i&lt;&lt;&quot;][&quot;&lt;&lt;j&lt;&lt;&quot;] : &quot;&lt;&lt; memo[i][j] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return memo[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123;</span><br><span class="line"> </span><br><span class="line">if (triangle.size() == 0)</span><br><span class="line">return 0;</span><br><span class="line"> </span><br><span class="line">// triangle中应该都是正数吧</span><br><span class="line">int res;</span><br><span class="line">m = triangle.size();</span><br><span class="line">//构造cache容器</span><br><span class="line">for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">vector&lt;int&gt; tmp(triangle[i].size(), -1);</span><br><span class="line">memo.push_back(tmp);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">res = minPathSum(triangle, 0, 0);</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>//犹记得当日的nlp课程的hmm状态转移方法，yangsky算法，一个句子在一个概率字典里找出最有可能的点。当时查找路径。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文链接：&lt;a href=&quot;https://blog.csdn.net/xdzhangzhenhao/article/details/81356095&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/xdzhang
      
    
    </summary>
    
    
      <category term="algorithm" scheme="http://pengw00.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>topK and quickSort and QuickSelect</title>
    <link href="http://pengw00.github.io/2019/04/03/topK-and-quickSort-and-QuickSelect/"/>
    <id>http://pengw00.github.io/2019/04/03/topK-and-quickSort-and-QuickSelect/</id>
    <published>2019-04-03T17:36:40.000Z</published>
    <updated>2019-04-04T03:33:39.349Z</updated>
    
    <content type="html"><![CDATA[<p>quick select 和quick sort方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;quick select 和quick sort方法&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://pengw00.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Quick Sort&#39; </title>
    <link href="http://pengw00.github.io/2019/04/03/Quick-Sort/"/>
    <id>http://pengw00.github.io/2019/04/03/Quick-Sort/</id>
    <published>2019-04-03T15:43:47.000Z</published>
    <updated>2019-04-03T15:50:48.701Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void quickSort(int[] arr, int low, int high)&#123;</span><br><span class="line">if(low&gt;high) return;</span><br><span class="line">int i = low, int j = high, base = arr[low];</span><br><span class="line">while(i &lt; j)&#123;</span><br><span class="line">while(arr[i]&lt;base &amp;&amp; i&lt;j)&#123;i++;&#125;</span><br><span class="line">while(arr[j]&gt;base &amp;&amp; i &lt; j)&#123; j--;&#125;</span><br><span class="line">//after that the order is messy</span><br><span class="line">swap(arr, low, j);</span><br><span class="line">&#125;</span><br><span class="line">swap(arr, base, j);</span><br><span class="line">quickSort(arr, low, j-1);</span><br><span class="line">quickSort(arr, j+1, high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void swap(int[] arr, int i, int j)&#123;</span><br><span class="line">int temp = arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = tamp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="algorithm" scheme="http://pengw00.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>axios instance</title>
    <link href="http://pengw00.github.io/2019/04/03/axios-instance/"/>
    <id>http://pengw00.github.io/2019/04/03/axios-instance/</id>
    <published>2019-04-03T14:31:17.000Z</published>
    <updated>2019-04-03T14:32:46.136Z</updated>
    
    <content type="html"><![CDATA[<p>Question??<br>axios.create({ baseURL: ajaxUrl,timeout: 30000,withCredentials: true}) 创建实例作用是啥 没有不行吗### 问题描述<br>引入axios,然后在页面中进行请求axios.get(‘url’).then(res=&gt;{}),这里的创建实例充当什么角色</p><p>Answer:<br>默认会导出实例axios，通常你只需使用这个axios就可以了。</p><p>但是有时候你需要创建多个实例，比如你需要访问多个服务地址，而这些服务请求和响应的结构都完全不同，那么你可以通过axios.create创建不同的实例来处理。</p><p>比如axios1是用http状态码确定响应是否正常，而axios2是服务器自己定义的状态码，又或者他们请求头不同，支持的content-type不同，那么我可以单独为axios1和axios2写拦截器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Question??&lt;br&gt;axios.create({ baseURL: ajaxUrl,timeout: 30000,withCredentials: true}) 创建实例作用是啥 没有不行吗### 问题描述&lt;br&gt;引入axios,然后在页面中进行请求axios.ge
      
    
    </summary>
    
    
      <category term="React" scheme="http://pengw00.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>dfs和回溯模版</title>
    <link href="http://pengw00.github.io/2019/04/03/dfs%E5%92%8C%E5%9B%9E%E6%BA%AF%E6%A8%A1%E7%89%88/"/>
    <id>http://pengw00.github.io/2019/04/03/dfs和回溯模版/</id>
    <published>2019-04-03T05:12:04.000Z</published>
    <updated>2019-04-04T04:58:36.680Z</updated>
    
    <content type="html"><![CDATA[<p>dfs template<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void f()  </span><br><span class="line">&#123;  </span><br><span class="line">     if(符合边界条件)  </span><br><span class="line">     &#123;  </span><br><span class="line"></span><br><span class="line">        ///////  </span><br><span class="line">        return;  </span><br><span class="line">     &#125;  </span><br><span class="line"></span><br><span class="line">     //某种形式的调用  </span><br><span class="line">     f();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>回溯模版： 限制条件 if，选择 （for。。。）结束条件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void DFS(int 当前状态)  </span><br><span class="line">&#123;  </span><br><span class="line">      if(当前状态为边界状态)  </span><br><span class="line">      &#123;  </span><br><span class="line">        记录或输出  </span><br><span class="line">        return;  </span><br><span class="line">      &#125;  </span><br><span class="line">      for(i=0;i&lt;n;i++)       //横向遍历解答树所有子节点  </span><br><span class="line">      &#123;  </span><br><span class="line">           //扩展出一个子状态。  </span><br><span class="line">           修改了全局变量  </span><br><span class="line">           if(子状态满足约束条件)  </span><br><span class="line">            &#123;  </span><br><span class="line">              dfs(子状态)  </span><br><span class="line">           &#125;  </span><br><span class="line">            恢复全局变量//回溯部分  </span><br><span class="line">      &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>BFS和DFS相似。BFS显式用队列，DFS隐式用栈，即递归。<br>当然，对于DFS，用递归可能会造成栈溢出，所以也可以更改为显示栈。</p><p>经典例题： 走迷宫<br>*表示可走 </p><p>#表示障碍<br>T表示出口<br>入口是(1,1)，数据保证左上角是入口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">char maze[100][100];</span><br><span class="line">bool flag[100][100];</span><br><span class="line">int dx[]=&#123;0,0,1,-1&#125;;</span><br><span class="line">int dy[]=&#123;1,-1,0,0&#125;;</span><br><span class="line">int m,n;</span><br><span class="line"></span><br><span class="line">bool dfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    flag[x][y]=1;              //走过的路标记为1</span><br><span class="line">    if(maze[x][y]==&apos;T&apos;)return true;</span><br><span class="line">    for(int i=0;i&lt;4;i++)       //四个方向</span><br><span class="line">    &#123;</span><br><span class="line">        int nx=x+dx[i];</span><br><span class="line">        int ny=y+dy[i];</span><br><span class="line">        if(flag[nx][ny]==0||maze[nx][ny]==&apos;*&apos;||maze[nx][ny]==&apos;T&apos;&amp;&amp;nx&gt;0&amp;&amp;ny&gt;0&amp;&amp;nx&lt;m+1&amp;&amp;ny&lt;n+1)</span><br><span class="line">        &#123;</span><br><span class="line">            return dfs(nx,ny);   </span><br><span class="line">            flag[nx][ny]=0;    //回溯，将标记重新标记为0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;             //找不到返回false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    while(cin&gt;&gt;m&gt;&gt;n)&#123;</span><br><span class="line">    memset(maze,0,sizeof(maze));</span><br><span class="line">    memset(flag,0,sizeof(flag));</span><br><span class="line">    for(int i=1;i&lt;=m;i++)</span><br><span class="line">        for(int j=1;j&lt;=n;j++)</span><br><span class="line">            cin&gt;&gt;maze[i][j];</span><br><span class="line">    if(dfs(1,1))cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">    else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回溯的两种写法：</p><p>递归写法和迭代写法，链接：<a href="https://blog.csdn.net/man_sion/article/details/74993907" target="_blank" rel="noopener">https://blog.csdn.net/man_sion/article/details/74993907</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;dfs template&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/s
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://pengw00.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>回溯，递归，dp三法leetcode 题目“ </title>
    <link href="http://pengw00.github.io/2019/04/03/%E5%9B%9E%E6%BA%AF%EF%BC%8C%E9%80%92%E5%BD%92%EF%BC%8Cdp%E4%B8%89%E6%B3%95leetcode-%E9%A2%98%E7%9B%AE%E2%80%9C/"/>
    <id>http://pengw00.github.io/2019/04/03/回溯，递归，dp三法leetcode-题目“/</id>
    <published>2019-04-03T04:30:53.000Z</published>
    <updated>2019-04-03T04:59:05.205Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode 10  regular expression matching 可以减去一字符<br>leetcode wildcard matching 可以匹配一个字符<br>leetcode edit distance<br>回溯三要素：选择，限制条件，结束条件<br>回溯是一种算法思想，它是用递归实现的。回溯的过程类似于穷举法，但回溯有“剪枝”功能，即自我判断过程。例如有求和问题，给定有 7 个元素的组合 [1, 2, 3, 4, 5, 6, 7]，求加和为 7 的子集。累加计算中，选择 1+2+3+4 时，判断得到结果为 10 大于 7，那么后面的 5, 6, 7 就没有必要计算了。这种方法属于搜索过程中的优化，即“剪枝”功能。</p><p>回溯法解决leetcode10注意递归和回溯的区别<br>回溯具有剪枝的功能。当出现结束条件，自动回溯，不必再往不必要的地方搜索。</p><p>我们在路上走着，前面是一个多岔路口，因为我们并不知道应该走哪条路，所以我们需要尝试。尝试的过程就是一个函数。<br>我们选择了一个方向，后来发现又有一个多岔路口，这时候又需要进行一次选择。所以我们需要在上一次尝试结果的基础上，再做一次尝试，即在函数内部再调用一次函数，这就是递归的过程。<br>这样重复了若干次之后，发现这次选择的这条路走不通，这时候我们知道我们上一个路口选错了，所以我们要回到上一个路口重新选择其他路，这就是回溯的思想。</p><p>递归和回溯相关题目：<br>leetcode17 letter Combinations of a Phone Number<br>leetcode22 Generate Parentheses(最为经典)<br>leetcode46 permutations<br>在 Backtracking 标签中，有 30+ 道与递归、回溯相关的例题</p><p>回溯搜索是深度优先搜索（DFS）的一种。对于某一个搜索树来说（搜索树是起记录路径和状态判断的作用），回溯和DFS，其主要的区别是，回溯法在求解过程中不保留完整的树结构，而深度优先搜索则记下完整的搜索树。</p><p><a href="http://www.cnblogs.com/shizhh/p/5302852.html" target="_blank" rel="noopener">http://www.cnblogs.com/shizhh/p/5302852.html</a> 动态规划系列问题汇总</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;leetcode 10  regular expression matching 可以减去一字符&lt;br&gt;leetcode wildcard matching 可以匹配一个字符&lt;br&gt;leetcode edit distance&lt;br&gt;回溯三要素：选择，限制条件，结束条件&lt;b
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://pengw00.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>springSecurity Bcrypt hash password</title>
    <link href="http://pengw00.github.io/2019/04/02/springSecurity-Bcrypt-hash-password/"/>
    <id>http://pengw00.github.io/2019/04/02/springSecurity-Bcrypt-hash-password/</id>
    <published>2019-04-02T04:12:46.000Z</published>
    <updated>2019-04-02T04:25:57.506Z</updated>
    
    <content type="html"><![CDATA[<p>SpringSecurity之加密篇—BCryptpassword类</p><ol><li>要点概括<br>BCryptpassword类是SpringSecurity的加密工具，封装了对密码混淆加密的方法，主要是采用盐（salt）对原始密码进行混淆。<br>本篇介绍的是利用BCryptpassword随机生成盐（salt），使用该盐值对原始密码进行混淆加密。<br>这种加密方式有两个特点：（1）将随机生成的盐（salt）存到混淆后的代码中；（2）对于相同的明文每一次加密，加密之后的密文都是不一样的；因为盐值（salt）不同。这样的好处就是更增加了密码的安全性。</li></ol><p>SpringSecurity中的BCryptPassword采用Hash处理，其过程是不可逆的。</p><p>BCryptPassword的加密过程：<br>（1）加密(encode)：用户注册时，使用SHA256+盐（salt）把用户输入的密码进行hash混淆处理，得到密码的hash值，然后将其存入数据库中。<br>（2）密码校验(matches)：用户登录时，密码匹配阶段并没有进行密码解密（因为密码经过Hash处理，是不可逆的），而是使用相同的算法结合盐值salt把用户输入的密码进行hash处理，得到密码的hash值，然后将其与从数据库中查询到的密码hash值进行比较。如果两者相同，说明用户输入的密码正确，这里的盐值（salt）是从数据库中查询到的密码hash值中解析出来的。</p><ol start="2"><li>核心代码分析<br>//1. BCryptPasswordEncoder类，生成盐salt并混淆rawpassword的代码；<br>//涉及到两个问题，生成salt盐gensalt()，混淆密码hashpw()<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public String encode(CharSequence rawPassword) &#123;</span><br><span class="line">    String salt;</span><br><span class="line">    if (this.strength &gt; 0) &#123;</span><br><span class="line">        if (this.random != null) &#123;</span><br><span class="line">            salt = BCrypt.gensalt(this.strength, this.random);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            salt = BCrypt.gensalt(this.strength);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        salt = BCrypt.gensalt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return BCrypt.hashpw(rawPassword.toString(), salt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>2.1 生成盐（salt）：<br>:包名：org.springframework.security.crypto.bcrypt；类名：BCrypt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//生成salt盐gensalt() </span><br><span class="line">   public static String gensalt(int log_rounds, SecureRandom random) &#123;</span><br><span class="line">       if (log_rounds &gt;= 4 &amp;&amp; log_rounds &lt;= 31) &#123;</span><br><span class="line">           StringBuilder rs = new StringBuilder();</span><br><span class="line">           byte[] rnd = new byte[16];</span><br><span class="line">           random.nextBytes(rnd);</span><br><span class="line">           rs.append(&quot;$2a$&quot;);</span><br><span class="line">           if (log_rounds &lt; 10) &#123;</span><br><span class="line">               rs.append(&quot;0&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           rs.append(log_rounds);</span><br><span class="line">           rs.append(&quot;$&quot;);</span><br><span class="line">           encode_base64(rnd, rnd.length, rs);</span><br><span class="line">           return rs.toString();</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           throw new IllegalArgumentException(&quot;Bad number of rounds&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>2.2 混淆方法：<br>包名：org.springframework.security.crypto.bcrypt；类名：BCrypt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">//混淆密码hashpw()</span><br><span class="line">public static String hashpw(String password, String salt) throws IllegalArgumentException &#123;</span><br><span class="line">        char minor = 0;</span><br><span class="line">        int off = false;</span><br><span class="line">        StringBuilder rs = new StringBuilder();</span><br><span class="line">        if (salt == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;salt cannot be null&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int saltLength = salt.length();</span><br><span class="line">            if (saltLength &lt; 28) &#123;</span><br><span class="line">                throw new IllegalArgumentException(&quot;Invalid salt&quot;);</span><br><span class="line">            &#125; else if (salt.charAt(0) == &apos;$&apos; &amp;&amp; salt.charAt(1) == &apos;2&apos;) &#123;</span><br><span class="line">                byte off;</span><br><span class="line">                if (salt.charAt(2) == &apos;$&apos;) &#123;</span><br><span class="line">                    off = 3;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    minor = salt.charAt(2);</span><br><span class="line">                    if (minor != &apos;a&apos; || salt.charAt(3) != &apos;$&apos;) &#123;</span><br><span class="line">                        throw new IllegalArgumentException(&quot;Invalid salt revision&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    off = 4;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (saltLength - off &lt; 25) &#123;</span><br><span class="line">                    throw new IllegalArgumentException(&quot;Invalid salt&quot;);</span><br><span class="line">                &#125; else if (salt.charAt(off + 2) &gt; &apos;$&apos;) &#123;</span><br><span class="line">                    throw new IllegalArgumentException(&quot;Missing salt rounds&quot;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    int rounds = Integer.parseInt(salt.substring(off, off + 2));</span><br><span class="line">                    String real_salt = salt.substring(off + 3, off + 25);</span><br><span class="line"></span><br><span class="line">                    byte[] passwordb;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        passwordb = (password + (minor &gt;= &apos;a&apos; ? &quot;\u0000&quot; : &quot;&quot;)).getBytes(&quot;UTF-8&quot;);</span><br><span class="line">                    &#125; catch (UnsupportedEncodingException var13) &#123;</span><br><span class="line">                        throw new AssertionError(&quot;UTF-8 is not supported&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    byte[] saltb = decode_base64(real_salt, 16);</span><br><span class="line">                    BCrypt B = new BCrypt();</span><br><span class="line">                    byte[] hashed = B.crypt_raw(passwordb, saltb, rounds);</span><br><span class="line">                    rs.append(&quot;$2&quot;);</span><br><span class="line">                    if (minor &gt;= &apos;a&apos;) &#123;</span><br><span class="line">                        rs.append(minor);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    rs.append(&quot;$&quot;);</span><br><span class="line">                    if (rounds &lt; 10) &#123;</span><br><span class="line">                        rs.append(&quot;0&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    rs.append(rounds);</span><br><span class="line">                    rs.append(&quot;$&quot;);</span><br><span class="line">                    encode_base64(saltb, saltb.length, rs);</span><br><span class="line">                    encode_base64(hashed, bf_crypt_ciphertext.length * 4 - 1, rs);</span><br><span class="line">                    return rs.toString();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new IllegalArgumentException(&quot;Invalid salt version&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>2.3 密码的校验<br>提供的密码与加密之后的密码的校验，使用是BCryptpassword的matches()接口；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public boolean matches(CharSequence rawPassword, String encodedPassword) &#123;</span><br><span class="line">    if (encodedPassword != null &amp;&amp; encodedPassword.length() != 0) &#123;</span><br><span class="line">        if (!this.BCRYPT_PATTERN.matcher(encodedPassword).matches()) &#123;</span><br><span class="line">            this.logger.warn(&quot;Encoded password does not look like BCrypt&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return BCrypt.checkpw(rawPassword.toString(), encodedPassword);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        this.logger.warn(&quot;Empty encoded password&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><pre><code>/** * 密码比较入口，同样是调用了hashpw()方法: 使用的是hashpw()方法，有两个参数：原始明文与数据库中获取的密文。 * hashpw()方法是从密文中解析出藏在其中的盐salt值，用此值混淆明文，与密文做比较。 */</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   public static boolean checkpw(String plaintext, String hashed) &#123;</span><br><span class="line">       return equalsNoEarlyReturn(hashed, hashpw(plaintext, hashed)); </span><br><span class="line">   &#125;</span><br><span class="line">//这个方法就是比较是否相同而已，无他。</span><br><span class="line">   static boolean equalsNoEarlyReturn(String a, String b) &#123;</span><br><span class="line">       char[] caa = a.toCharArray();</span><br><span class="line">       char[] cab = b.toCharArray();</span><br><span class="line">       if (caa.length != cab.length) &#123;</span><br><span class="line">           return false;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           byte ret = 0;</span><br><span class="line"></span><br><span class="line">           for(int i = 0; i &lt; caa.length; ++i) &#123;</span><br><span class="line">               ret = (byte)(ret | caa[i] ^ cab[i]);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           return ret == 0;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>总结<br>以上是SpringSecurity的BCryptPassword加密方式，上面是介绍其SHA256+随机salt生成密文的基本点。应该还有其他的一些用法，容当后研究。</p></li><li><p>其它<br>Springboot框架整合SpringSecurity组件，使用需要使用该加密方式，有一点需要注意，就是在springSecurity的配置文件中注入PasswordEncode的bean</p><p> //SpringSecurityConfigutarion配置类中加入<br> @Bean<br> public PasswordEncoder passwordEncoder() {</p><pre><code>return new BCryptPasswordEncoder();</code></pre><p> }<br>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       String password = &quot;leo_epam&quot;;</span><br><span class="line">        System.out.println(password + &quot;: encrypt&quot;);</span><br><span class="line">        int i = 0;</span><br><span class="line">        while(i &lt; 10)&#123;</span><br><span class="line">            BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();</span><br><span class="line">            String hashedPassword = passwordEncoder.encode(password);</span><br><span class="line">            System.out.println(&quot;encryptPassword:&quot; + hashedPassword);</span><br><span class="line">            System.out.println(&quot;match result:&quot; + passwordEncoder.matches(password,hashedPassword));</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p>代码输出：</p><p>leo_epam: encrypt<br>encryptPassword:$2a$10$/WIa4YbBMGQX7dBbYwRKx.AmQ3sJ8Ta5wYHh8a7jPlYDbNgMSD/hC<br>match result:true<br>encryptPassword:$2a$10$VryRC1lFaTEqUbOUyvu18ulSSGH5hK7JPzAG17ehtkL8aV6fot1ru<br>match result:true<br>encryptPassword:$2a$10$0SVRXbfgsqMvpmNDeeqNl.eFPvQ0ojdazk5.x8YDZxIOOP1D4xXge<br>match result:true<br>encryptPassword:$2a$10$yWdI4q6DXDZhknTxiT/9ROdhcAARAEY5q4L2YI5uQ3C52Q7Lt/IAa<br>match result:true<br>encryptPassword:$2a$10$8yy0.NdQSD2Cig5yIri2eu1XmDRpZSPjsmxDyRg9CZ5afwp/36H2S<br>match result:true<br>encryptPassword:$2a$10$QTJpm3jYUCjAoHPVI/uon.FDusm.9tPSc.mk6m.l/kx8aKbIzov3i<br>match result:true<br>encryptPassword:$2a$10$CkoGrZqDE86LM1yiX89cpuNDAMdDqemEKMSS3/jquFsxocizgBbX2<br>match result:true<br>encryptPassword:$2a$10$6M0N6cQp6kKeXgRl8ftqyOlikAV9YwfMS93xlqTXbd/tmDjFDv3iG<br>match result:true<br>encryptPassword:$2a$10$LboMUNAF7vOmucxJI3G/w.cliDRxH1exOmsfy2IlPCUpZU8N7XoO.<br>match result:true<br>encryptPassword:$2a$10$ezB0okY.JHv1gt4Y3chiu.5e5R9.vXqd7kNaYH14Vigm9wZ02D8Pe<br>match result:true<br>以上代码就是BCryptPassword的代码简单效果示例，相同的明文，每次生成的密文都是不同的，但是和明文做密码校验都是通过的。<br>还有一个就是密码字段的长度，如果打算采用bcrypt加密存储，字段长度不得低于60.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SpringSecurity之加密篇—BCryptpassword类&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;要点概括&lt;br&gt;BCryptpassword类是SpringSecurity的加密工具，封装了对密码混淆加密的方法，主要是采用盐（salt）对原始密码进行混淆。&lt;br&gt;本篇介绍的
      
    
    </summary>
    
    
      <category term="spring" scheme="http://pengw00.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate</title>
    <link href="http://pengw00.github.io/2019/04/02/Hibernate/"/>
    <id>http://pengw00.github.io/2019/04/02/Hibernate/</id>
    <published>2019-04-02T04:00:27.000Z</published>
    <updated>2019-04-02T04:03:59.330Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Hibernate的工作原理是什么？为什么要用hibernate？</li></ol><p>（1）Hibernate可以理解为一个中间件。它负责把java程序的SQL语句接收过来并发送到数据库，而数据库返回的信息由Hibernate接收后直接生成一个对象传给java.</p><p>在Hibernate中有两个特有的文件，一个是以.hbm.xml结尾的映射文件，一个是以.cfg.xml结尾的配置文件。.cfg.xml文件的作用是连接数据库，文件内部其实就是一个由user,password，url,driver组成的链接库的基本信息。.hbm.xml文件是对数据库中表的映射文件。</p><p>（2）Hibernate工作原理</p><p>①读取并解析hibernate.cfg.xml配置文件；</p><p>②由hibernate.cfg.xml中的<mapping resource="com/xx/user.hbm.xml">读取并解析映射信息；</mapping></p><p>③.通过SessionFactory sf = config.buildSessionFactory();创建SessionFactory</p><p>④Session session = sf.openSession();//打开Sesssion</p><p>⑤Transaction tx = session.beginTransaction();//创建并启动事务Transation</p><p>⑥persistent operate操作数据，持久化操作</p><p>⑦tx.commit();//提交事务</p><p>⑧关闭Session</p><p>⑨关闭SesstionFactory</p><p>3）使用Hibernate的原因如下：</p><p>① 对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。</p><p>②HIbernate是基于JDBC的主流持久化框架，是一个优秀的对象关系映射实现，它在很大程度上简化了DAO层的编码工作；</p><p>③Hibernate使用java反射机制，而不是字节码增强程序来实现透明性；</p><h2 id="④Hibernate性能非常好，因为它是一个轻量级框架，映射的灵活性很出色，它支持各种关系数据库，从一对一到多对多的各种复杂关系。"><a href="#④Hibernate性能非常好，因为它是一个轻量级框架，映射的灵活性很出色，它支持各种关系数据库，从一对一到多对多的各种复杂关系。" class="headerlink" title="④Hibernate性能非常好，因为它是一个轻量级框架，映射的灵活性很出色，它支持各种关系数据库，从一对一到多对多的各种复杂关系。"></a>④Hibernate性能非常好，因为它是一个轻量级框架，映射的灵活性很出色，它支持各种关系数据库，从一对一到多对多的各种复杂关系。</h2><p>为什么要持久化？ 持久化技术封装了数据访问细节，为大部分业务逻辑提供面向对象的API。 ● 通过持久化技术可以减少访问数据库数据次数，增加应用程序执行速度； ● 代码重用性高，能够完成大部分数据库操作； ● 松散耦合，使持久化不依赖于底层数据库和上层业务逻辑实现，更换数据库时只需修改配置文件而不用修改代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;Hibernate的工作原理是什么？为什么要用hibernate？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（1）Hibernate可以理解为一个中间件。它负责把java程序的SQL语句接收过来并发送到数据库，而数据库返回的信息由Hibernate接收后直接生成一个对象传给
      
    
    </summary>
    
    
      <category term="hibernate" scheme="http://pengw00.github.io/tags/hibernate/"/>
    
  </entry>
  
  <entry>
    <title>被amazon开出两次的经验总结</title>
    <link href="http://pengw00.github.io/2019/03/30/%E8%A2%ABamazon%E5%BC%80%E5%87%BA%E4%B8%A4%E6%AC%A1%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    <id>http://pengw00.github.io/2019/03/30/被amazon开出两次的经验总结/</id>
    <published>2019-03-30T19:04:14.000Z</published>
    <updated>2019-03-30T19:18:27.437Z</updated>
    
    <content type="html"><![CDATA[<p>1.政治斗争： fight all days, impossible to work</p><ol start="2"><li>status: hardworking, burn the middnight oil</li></ol><p>收获： 学会了亚马逊的生存法则<br>为什么离开： 需要pip， ？？<br>进去三个月被dev， 第二次因为组里launch新的项目，没有和其他组员抢活，被安排做operating&amp;&amp; bug之类的活，导致没有大项目来support 年度review</p><ol start="2"><li>把项目技术挖深了，确保工作安全。<br>和老板沟通，确定目前最重要的活是什么，focus在老板最关心的活上。确定掌握核心资源的是谁，积极主动去合作，拿可见度最高的活儿。</li><li>学会说不，组里同事塞给你，一般是知道是坑，学会优雅避开，比如我觉得xxx优先级比较高，我先focus on做完x，别的组找你帮忙，尽量给点帮助，别花太多时间，如果需要花很多时间，赵老板，老板会帮你退掉。<br>4.留证据<br>每周把做过的事给老板总结，要feedback，可以提高自己，也可以留证据，别人要开你的话，你都有wittern证据。</li><li><p>别的组问问题，不要给书面承诺，比如我会帮你debug之类，第一对方可能得寸进尺。第二，等别人要你帮忙的时候你可能没时间了真，问别人组的问题，尽量要书面email node， 或者可以开个简会马上把meeting note发出来，没人能赖账。 </p></li><li><p>后来加一点，能不去tech debt重的组就就尽量不去，天天修东西，没时间学习，没时间做项目。比如某语音助手的内核组。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.政治斗争： fight all days, impossible to work&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;status: hardworking, burn the middnight oil&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;收获： 学会了亚马逊的生存
      
    
    </summary>
    
    
      <category term="career" scheme="http://pengw00.github.io/tags/career/"/>
    
  </entry>
  
</feed>
